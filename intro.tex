\chapter{Introduction}
\label{cha:intro}

\subsection{Constraint Satisfaction Problems}
CSP's zijn problemen waar voor een reeks variabelen een geldige waarde uit het domein dient toegekend te worden. De toekenning echter is gebonden aan een set van regels waaraan de variabelen moeten voldoen. Formeel defini\"{e}ren we een CSP als een triple $\langle \mathcal{X},\mathcal{D},\mathcal{C} \rangle$, met $\mathcal{X}$ de verzameling van variabelen, $\mathcal{D}$ de domeinwaarden voor deze variabelen en $\mathcal{C}$ de constraints over de variabelen. Typisch worden dit soort problemen opgelost d.m.v. zoeken door alle mogelijk combinaties, deze recursieve methode gaat voor elke nieuwe toekenning na of de constraints voor de parti\"{e}le toekenning consistent zijn. Zo ja, dan volgt er een nieuwe recursieve oproep, anders gaat het algoritme backtracken. Het oplossen van CSP's met een eindig domein behoort tot de klasse van NP-Complete problemen en de berekeningen zijn vaak van hoge complexiteit met betrekking tot de grootte van het domein. Om het zoekproces proberen te versnellen bestaan er variaties op backtracking zoals backmarking en backjumping. De eerste zorgt voor een effici\"{e}ntere manier om consistentie na te gaan en backjumping is een betere manier van backtracking waarbij men over meerdere waarden tegelijk kan backtracken. Deze technieken versnellen het zoekproces in dat ze onnodige stappen detecteren en overslaan. Anderzijds bestaan er propagatie technieken die lokale consistentie garanderen met technieken zoals arc consistency, hyper-arc consistency en path-consistency die de domeinen van de variabelen proberen te verkleinen alvorens het zoekproces gestart wordt. 


\subsection{Interactive Configuration Problems}
In deze thesis ligt de focus op een specifieke groep van problemen binnen het domein van CSP's genaamd Interactieve Configuratieproblemen (IC). Constraint Satisfaction Problems zijn problemen waar een toekenning van domeinwaarden voor de variabelen dient gevonden te worden waarvoor geldt dat aan alle constraints voldaan is. IC problemen hebben hetzelfde doel, maar bij CSP's wordt er naar een toekenning gezocht d.m.v. recursieve zoektechnieken terwijl het in het geval van IC problemen een gebruiker is die handmatig stap per stap een geldige toekenning gaat proberen samenstellen. Om de gebruiker hierin bij te staan is er nood aan software die de gebruiker zo goed mogelijk bijstaat gedurende dit hele proces. Uit ervaring is gebleken dat het schrijven van software voor dit soort problemen geen gemakkelijke opgave is. Zo is aangetoond dat een imperatieve aanpak voor het beschrijven van de regels van een probleem vaak moeilijk is \citep{gelle1996interactive}. Reden hiervoor is dat de regels over de betreffende domeinkennis vaak verspreid zit in de software in codesnippets. Daarbij is onderhoud van zulke software een enorm moeilijke opgave waarbij de kleinste wijziging in de constraints kan leiden tot een volledige herwerking van de code. Een alternatief hiervoor is een daclaratieve aanpak. In declaratieve toepassingen kunnen de regels van een probleem beschreven worden d.m.v. logische constraints. \cite{gelle1996interactive} laten niet alleen zien dat de declaratieve beschrijving van een probleem overzichtelijker en duidelijker is maar ook dat een wijziging in de constraints gemakkelijk aangepast kan worden. En hoewel er met een imperatieve aanpak optimalere algoritmen ontwikkeld kunnen worden, is aangetoond dat declaratieve methoden ook goede prestaties kunnen neerzetten. 

Het werk van\citep{vlaeminck2009logical} legt gelijkaardige argumenten voor. De paper verwijst naar een voorbeeld (Tax on web) waarbij een imperatieve aanpak inderdaad nadelig bleek te zijn. Het werk stelt een declaratieve aanpak voor voor het beschrijven van de regels van een probleem en inferentie om vragen erover op te lossen. Opnieuw met dezelfde resultaten namelijk een veel effici\"{e}ntere manier van beschrijven in een overzichtelijke set van logische regels, en ondanks een declaratieve aanpak toch (voor het gekozen probleem) een goede reactietijd van de inferentiemethoden.

\subsection{Het IDP Systeem}
Er zijn ondertussen vele declaratieve systemen verschenen (Prolog, Ant, Lisp, ...). Wat opvalt is dat elk systeem vaak gebonden is aan \'{e}\'{e}n enkele specifieke vorm van inferentie. Afhankelijk van de gewenste inferentie zal een probleem dus opnieuw moeten beschreven worden in een ander systeem waarmee deze vorm van inferentie wel mogelijk is, ondanks het feit dat de kennis telkens dezelfde is. Deze gedachtegang ligt aan de basis van het concept van het Kennisbank paradigma \citep{denecker2008building}. In het KB-paradigma wordt gesteld dat de inferentie los staat van de kennis over een probleem. Deze kennis is niets meer dan een verzameling van informatie, maar met deze informatie kunnen meerdere vormen van inferentie toegepast worden. In dit onderzoek ligt de aandacht op IDP, een KB-systeem ontwikkeld aan de K.U. Leuven en voor het eerst voorgesteld in 2008. Het laat toe om de kennis over een probleem te beschrijven in FO(\textperiodcentered), dit is eerste orde logica maar uitgebreid met aggregaten, type definities en inductieve definities. 

In \citep{wittocx2008idp} wordt de vergelijking gemaakt tussen IDP en ASP solvers. ASP oftewel Answer Set Programming is een populaire techniek voor het berekening van oplossingen (model expansie) voor een logisch probleem. Verscheidene systemen waaronder het bekende \textit{Clasp} zijn een implementatie van het ASP paradigma. IDP zelf maakt gebruik van een combinatie van ASP en SAT. In de paper tonen de auteurs het resultaat van een vergelijkende studie tussen verschillende model expansie systemen op een verzameling van problemen. Let hoe de focus enkel ligt op model expansie en niet op de andere vormen van inferentie die ook mogelijk zijn met IDP. De resultaten tonen dat IDP naast alle andere solvers ook goede prestaties behaalt. Bovenop deze cijfers wordt ook nog eens benadrukt dat de rijke en elegante taal die IDP gebruikt voor het beschrijven van problemen wellicht het belangrijkste onderdeel is van het systeem. Het gebruik van eerste orde logica uitgebreid met aggregaten, types, inductieve definities, parti\"{e}le functies, rekenkundige bewerkingen enz. maakt het beschrijven van problemen veel makkelijker. En hoewel de klasse van problemen die het kan beschrijven niet groter wordt, is het mogelijk dat de klasse van problemen die opgelost kunnen worden wel groter wordt (vb. reachability problemen).

De solver van het IDP systeem is de MiniSAT(ID) solver. \citep{de2014minisat} is een vergelijkende studie tussen MiniSAT(ID) en Gringo-Clasp. De laatste was de winnaar van de ASP wedstrijd in 2013 voor de categorie Model-and-Solve waar IDP als vierde eindigde. Voor sommige van de problemen werd IDP echter gediskwalificeerd door problemen met het modelleren. Daarom hebben de auteurs het IDP opnieuw getest tegen de problemen van de wedstrijd en de resultaten vergeleken met die van Gringo-Clasp. De uitkomst tonen dat Gringo-Clasp meer instanties van de problemen heeft kunnen oplossen dan IDP en hier vaak ook minder tijd voor nodig had. Maar dit is volgens de auteurs te wijten aan de manier waarop de problemen gemodelleerd zijn. In IDP zijn modellen vaak simpel en minder fine-tuned dan bij Gringo-Clasp. Daar bestaan ze vaker uit veel meer regels en bevatten sommige modellen zelfs complexe optimalisatie regels voor bijvoorbeeld symmetry breaking. Voor problemen waar de modelleren gelijkaardig zijn liggen de resultaten zeer dicht bij elkaar. 

Deze vergelijkende studies zijn niet de enigste positieve bewijzen van de kracht en voordelen van IDP. Het werk van \citep{vlaeminck2009logical} wijst net zoals \cite{gelle1996interactive} op de voordelen van een declaratieve aanpak. Maar deze resultaten zijn te wijten aan het gebruik van IDP. Wellicht de meest interessante case study is die van \citep{van2016kb} waar de auteurs een interactief configuratieprobleem van aanzienlijke schaal voor het consultancy bedrijf Active Planet beschrijven en oplossen met behulp van IDP. Opnieuw zijn de resultaten bevestigend en positief. Vennekens evalueert het resultaat op negen criteria voorgesteld in het boek van \citep{felfernig2014knowledge}. Deze zijn bedoeld om een beter beeld te geven van de prestaties van een configuratiesysteem. 
/*OPSOMMEN?*/
De score op deze criteria wordt vergeleken met die van tien andere bekende systemen, en toont duidelijk dat IDP \'{e}\'{e}n van de beste scores behaalt volgens deze negen criteria. 

\section{Probleemstelling}

\subsection{Individueel Studieprogramma}
Een ISP samenstellen valt onder de categorie van Interactieve Configuratieproblemen. De gebruiker, in dit geval een toekomstige student, wil een geldig ISP bekomen d.m.v. het selecteren van mogelijke opleidingsonderdelen (vakken) voor de door hem/haar gekozen opleiding. Maar de student kan niet zomaar elk opleidingsonderdeel selecteren, er zijn een heleboel regels waaraan de selectie moet voldoen. Deze regels zijn op zichzelf duidelijk en intu\"{i}tief, maar een selectie vinden die aan alle regels voldoet kan mogelijk verwarrend zijn. Het huidige systeem, een web applicatie op de website van de universiteit voorziet wel enige ondersteuning gedurende het selectieproces. De student kan simpelweg vakken selecteren door in vinkje te zetten in de checkbox dat bij een bepaald vak hoort, deze selectie kan ongedaan gemaakt worden door dit vinkje weer weg te klikken. Wanneer de student tevreden is met de selectie, kan hij/zij diens keuze bevestigen en het systeem zal dan controleren of de selectie voldoet aan de regels van het ISP. Is dit niet het geval dan wordt de student hiervan op de hoogte gebracht en wordt er uitleg (verklaring in natuurlijke taal) voorzien waarom ze niet klopt. Dit niveau van ondersteuning is op zich voldoende en iedere student zal uiteindelijk in staat zijn een geldig ISP samen te stellen. /*WAT WILLEN WE ANDERS MET IDP*/

\subsection{Conflict Explanation}
In een interactief configuratieprobleem is een gebruiker verantwoordelijk voor de toekenning van de waarden aan de variabelen, en het is goed mogelijk dat deze keuzes niet voldoen aan de regels van het probleem. Sinds het de verantwoordelijkheid is van het systeem om de gebruiker ondersteuning te bieden, moet het deze conflicten kunnen detecteren en aan de gebruiker kunnen duidelijk maken wat er precies mis is zodanig dat er een oplossing gevonden kan worden. Hier komt nog eens bij dat IC problemen een snelle reactietijd vereisen, de gebruiker mag niet meer dan een paar seconden wachten op een antwoord. 
/*HERSCHRIJVEN*/
Meerdere technieken voor het verklaren en oplossen van conflicten zijn reeds voorgesteld \cite{o2005generating} \cite{o2007representative} \cite{felfernig2001intelligent}. IDP zelf beschikt momenteel ook over enkele technieken voor conflict explanation, zo zijn er de unsatstructure en de unsattheory.


\section{Doel}
In deze thesis wil ik onderzoeken of de regels van het ISP effici\"{e}nt kunnen beschreven worden in FO(\textperiodcentered). De regels zijn voor elke opleiding anders. De vraag is of het mogelijk is om met \'{e}\'{e}n enkele theorie in IDP meerdere opleidingen correct te kunnen beschrijven. Belangrijk hierbij is dat de domeinen evenals de regels sterk kunnen verschillen tussen opleidingen, en dat de eventuele theorie hier mee om moet kunnen gaan. 

Het systeem van de K.U. Leuven biedt de ondersteuning nodig om een geldig ISP te kunnen samenstellen. Een interessante vraag is of een applicatie gebaseerd op IDP dezelfde als niet betere ondersteuning kan bieden. In een zelf ontworpen Front-end met grafische user interface wil ik de volgende functionaliteiten integreren:
\begin{description}
\item[Automatisch invullen van gevolgen] Als de student een vak A kiest en hieruit volgt dat vak B ook gevolgt moet worden, dan is het de bedoeling dat het systeem dit automatisch invult zodat de student zich hier verder niets van hoeft aan te trekken. 
\item[Detectie van foutieve selectie] Deze functionaliteit is momenteel al aanwezig in het huidige systeem. Maar de detectie gebeurt pas bij de bevestiging van de selectie i.p.v. op het moment van de selectie zelf. En dat is wat ik zal proberen te integreren in de nieuwe front-end. En niet enkel dit, maar ook het effectief opsporen van de oorzaak zodat de gebruiker dit kan aanpassen.
\item[Geldig ISP laten genereren] Stel dat een student keuzes heeft gemaakt omtrend de vakken die hij/zij echt wil of niet wil volgen, maar de selectie is nog geen volledige oplossing. Dan kan de student vragen aan het systeem om de selectie verder in te vullen.
\item[Optimaal ISP laten genereren] Niet alleen moet het systeem een geldige oplossing kunnen genereren, maar ook de beste oplossing volgens een bepaald criterium. Zo zou een student bijvoorbeeld graag een ISP willen waarbij de werklast zo goed mogelijk verdeeld is over beide semester. 
\item[Ongedaan maken van acties] Deze functionaliteit is terug te vinden in zowat de meeste moderne systemen. Als een student ontevreden is over zijn/haar recente keuzes, moet er de mogelijk zijn om deze ongedaan te kunnen maken. 
\item[Weergave van het lessenrooster] Zoals voorheen vermeld hebben studenten geen duidelijk overzicht van het lessenrooster dat voortvloeit uit hun keuzes. Vakken kunnen lesmomenten hebben die mogelijk overlappen met die van andere vakken en dit kan voor een ongewenste verrassing zorgen eens het ISP bevestigd is. Het is mijn bedoeling om in de nieuwe front-end wel een eventueel lessenrooster weer te geven.
\end{description}
De meeste van deze functionaliteiten steunen op inferentie technieken die IDP aanbiedt zoals model expansie, minimizatie, propagatie etc. Dit wil zeggen dat om deze functionaliteiten te kunnen aanbieden, de onderliggende inferentie technieken effici\"{e}nt moeten werken. Herinner dat we te maken hebben met een IC probleem en dit vereist dat de reactietijd niet meer dan enkele seconden bedraagt. Onderzoek zal dus moeten uitwijzen of inferentie snel verloopt voor dit probleem.

Naast het testen van de mogelijkheden van IDP voor het ISP probleem, heeft deze thesis nog een andere doel. De notie van conflict explanation werd reeds aangehaald, en het is mijn doel om de doeltreffendheid van sommige methodes te testen op het ISP probleem. Het opsporen van foutieve selecties met de unsatstructure is \'{e}\'{e}n ding, maar kunnen \textit{verklaren} wat er mis is met de selectie of oplossingen bieden is een geheel andere opgave. Verscheidene technieken zijn al onderzocht en voorgesteld en IDP zelf voorziet ook al de unsattheory, een methode die op zoek gaat naar de regels die (in geval van niet-satisfieerbaarheid) nooit waar gemaakt kunnen worden. Probleem is echter dat de output hiervan geformuleerd is in FO(\textperiodcentered), en een doorsnee gebruiker zal niet in staat zijn om hieruit iets te kunnen afleiden. Reified constraints zouden hier een oplossing voor kunnen zijn. Dus de unsatstructure kan de oorzaak van het conflict aanwijzen, terwijl reified constraints als ze voldoen aan de verwachtingen een verklaring in natuurlijke taal kunnen geven voor de regels die overtreden zijn. Een laatste manier die kan helpen bij het oplossen van conflicten is het opsommen van mogelijke oplossingen. Met oplossing wordt bedoelt, de kleinste verzameling van selecties die dienen ongedaan gemaakt te worden zodanig dat de rest van de selectie terug satisfieerbaar is. Om dit te kunnen implementeren baseer ik mij op het werk van \citep{amilhastre2002consistency}.

\section{Dependencies}
/*HERSCHRIJVEN*/
\begin{description}
\item [FO(\textperiodcentered)] Het is de bedoeling om de mogelijkheden van IDP in actie te zien en met een proof of concept de prestaties van het systeem te testen. FO(\textperiodcentered) bezit een grote uitdrukkingskracht, bovenop eerste order logica bevat het ook taalelementen zoals aggregaten (sum, avg, min, max, ..) en inductieve definities.
\item [Kivy] Bij de keuze van de programmeertaal en framework viel mijn oog op Kivy. Dit is een Python library met een hele waaier aan grafische elementen die elk uitgebreid geconfigureert kunnen worden. Hiervoor kan gebruik gemaakt worden van een door de uitgever ontwikkelde kv-language. Kivy applicaties werken cross-platform en de applicaties zijn event-driven gebruik makend van een centrale loop.
\item [JSON] Het gegevensformaat van JSON is ideaal om de domeinen van verschillende opleidingen in weer te geven. De domeinwaarden zitten gekoppeld aan een attribuut, dit maakt het gemakkelijk om structuur te parsen en zo het domein voor iederen opleiding in te lezen.
\item [Java] De eindige toestandsautomaat uit de paper van \citep{amilhastre2002consistency} is gebouwd in java, hierbij maak ik gebruik van de 'brics' automaton library. Deze library is simpel in gebruik en biedt handige tools die essentieel zijn voor de bouw van de automaat zoals FSA minimizatie. 
\end{description}