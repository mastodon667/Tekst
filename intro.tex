\chapter{Introduction}
\label{cha:intro}

\subsection{Constraint Satisfaction Problems}
CSP's zijn problemen waar voor een reeks variabelen een geldige waarde uit het domein dient toegekend te worden. De toekenning echter is gebonden aan een set van regels waaraan de variabelen moeten voldoen. Formeel defini\"{e}ren we een CSP als een triple $\langle \mathcal{X},\mathcal{D},\mathcal{C} \rangle$, met $\mathcal{X}$ de verzameling van variabelen, $\mathcal{D}$ de domeinwaarden voor deze variabelen en $\mathcal{C}$ de constraints over de variabelen. Typisch worden dit soort problemen opgelost d.m.v. zoeken door alle mogelijk combinaties, deze recursieve methode gaat voor elke nieuwe toekenning na of de constraints voor de parti\"{e}le toekenning consistent zijn. Zo ja, dan volgt er een nieuwe recursieve oproep, anders gaat het algoritme backtracken. Het oplossen van CSP's met een eindig domein behoort tot de klasse van NP-complete problemen en de berekeningen zijn vaak van hoge complexiteit met betrekking tot de grootte van het domein. Om het zoekproces proberen te versnellen bestaan er variaties op backtracking zoals backmarking en backjumping. De eerste zorgt voor een effici\"{e}ntere manier om consistentie na te gaan en backjumping is een betere manier van backtracking waarbij men over meerdere waarden tegelijk kan backtracken. Deze technieken versnellen het zoekproces in dat ze onnodige stappen detecteren en overslaan. Anderzijds bestaan er propagatie technieken die lokale consistentie garanderen met technieken zoals arc consistency, hyper-arc consistency en path-consistency die de domeinen van de variabelen proberen te verkleinen alvorens het zoekproces gestart wordt. Naast dit soort technieken wordt er ook vaak gebruik gemaakt van zoekalgoritmen die gebruik maken van heuristieken om de grote zoekruimte van een probleem te proberen verkleinen en zo sneller tot een oplossing te komen. Wanneer voor elke variabele $\mathcal{X}_{i}$ een waarde uit diens domein $\mathcal{D}_{i}$ is toegekend door het zoekproces en voor deze combinatie van toekenning geldt dat elke constraint $\mathcal{C}_{j} \in \mathcal{C}$ consistent is, dan wordt er gesproken van een oplossing. 


\subsection{Interactive Configuration Problems}
In deze thesis ligt de focus op een specifieke groep van problemen binnen het domein van CSP's genaamd Interactieve Configuratieproblemen (IC). Constraint Satisfaction Problems zijn problemen waar een toekenning van domeinwaarden voor de variabelen dient gevonden te worden waarvoor geldt dat aan alle constraints voldaan is. IC problemen hebben hetzelfde doel, maar bij CSP's wordt er naar een toekenning gezocht d.m.v. recursieve zoektechnieken terwijl het in het geval van IC problemen een gebruiker is die handmatig stap per stap een geldige toekenning gaat proberen samenstellen. Om de gebruiker hierin bij te staan is er nood aan software die de gebruiker zo goed mogelijk bijstaat gedurende dit hele proces. Uit ervaring is gebleken dat het schrijven van software voor dit soort problemen geen gemakkelijke opgave is. Zo is aangetoond dat een imperatieve aanpak voor het beschrijven van de regels van een probleem vaak moeilijk is \citep{gelle1996interactive}. Reden hiervoor is dat de regels over de betreffende domeinkennis vaak verspreid zit in de software in codesnippets. Daarbij is onderhoud van zulke software een enorm moeilijke opgave waarbij de kleinste wijziging in de constraints kan leiden tot een volledige herwerking van de code. Een alternatief hiervoor is een daclaratieve aanpak. In declaratieve toepassingen kunnen de regels van een probleem beschreven worden d.m.v. logische constraints. \cite{gelle1996interactive} laten niet alleen zien dat de declaratieve beschrijving van een probleem overzichtelijker en duidelijker is maar ook dat een wijziging in de constraints gemakkelijk aangepast kan worden. En hoewel er met een imperatieve aanpak meer optimale algoritmen ontwikkeld kunnen worden, is aangetoond dat declaratieve methoden ook goede prestaties kunnen neerzetten. Het werk van\citep{vlaeminck2009logical} legt gelijkaardige argumenten voor. De paper verwijst naar een voorbeeld (Tax on web) waarbij een imperatieve aanpak inderdaad nadelig bleek te zijn. Het werk stelt een declaratieve aanpak voor voor het beschrijven van de regels van een probleem en inferentie om vragen erover op te lossen. Ook zij concluderen veel effici\"{e}ntere manier van beschrijven in een overzichtelijke set van logische regels, en ondanks een declaratieve aanpak toch (voor het gekozen probleem) een goede reactietijd van de inferentie methoden.

\subsection{Declaratieve Systemen}
Er zijn ondertussen vele declaratieve systemen verschenen (Prolog, Ant, Lisp, ...). Wat opvalt is dat elk systeem vaak gebonden is aan \'{e}\'{e}n enkele specifieke vorm van inferentie. Afhankelijk van de gewenste inferentie zal een probleem dus opnieuw moeten beschreven worden in een ander systeem waarmee deze vorm van inferentie wel mogelijk is, ondanks het feit dat de kennis telkens dezelfde is. 

\paragraph{Het IDP Systeem}
Deze gedachtegang ligt aan de basis van het concept van het Kennisbank paradigma \citep{denecker2008building}. In het KB-paradigma wordt gesteld dat de inferentie los staat van de kennis over een probleem. Deze kennis is niets meer dan een verzameling van informatie, maar op deze informatie kunnen meerdere vormen van inferentie toegepast worden. In dit onderzoek ligt de aandacht op IDP, een KB-systeem ontwikkeld aan de K.U. Leuven en voor het eerst voorgesteld in 2008. Het laat toe om de kennis over een probleem te beschrijven in FO(\textperiodcentered), dit is eerste orde logica maar uitgebreid met aggregaten, type definities en inductieve definities. IDP integreert state-of-the-art technologie\"{e}n uit Answer Set Programming (ASP) en SAT solving voor het oplossen van inferentie taken. De architectuur van IDP bestaat uit twee delen, een grounder en een solver. De taak van de grounder is om de input structuur om te vormen tot een formaat dat de solver begrijpt, dit formaat is een extensie van de conjunctieve normaalvorm (ECNF). De solver van het IDP systeem is de MiniSAT(ID) solver \citep{de2014minisat}.

\paragraph{Andere systemen}
/*INVULLEN*/

\paragraph{Vergelijking met andere systemen}
IDP is niet het enige systeem dat gebruikt zou kunnen worden om te helpen de vragen in dit onderzoek te beantwoorden. IDP en diens notie van het KB-paradigma maken het echter wel een aantrekkelijke kandidaat. Deze motivatie achter deze keuze is ook te wijten aan de resultaten van enkele gerelateerde studies. 

In \citep{wittocx2008idp} wordt de vergelijking gemaakt tussen IDP en ASP solvers. ASP oftewel Answer Set Programming is een populaire techniek voor het berekening van oplossingen (model expansie) voor een logisch probleem. Verscheidene systemen waaronder het bekende \textit{Clasp} zijn een implementatie van het ASP paradigma. IDP zelf maakt gebruik van een combinatie van ASP en SAT. In de paper tonen de auteurs het resultaat van een vergelijkende studie tussen verschillende model expansie systemen op een verzameling van problemen. Merk op dat de focus enkel ligt op model expansie en niet op de andere vormen van inferentie die ook mogelijk zijn met IDP. De resultaten tonen dat IDP naast alle andere solvers ook goede prestaties behaalt. Bovenop deze cijfers wordt ook nog eens benadrukt dat de rijke en elegante taal die IDP gebruikt voor het beschrijven van problemen wellicht het belangrijkste onderdeel is van het systeem. Het gebruik van eerste orde logica uitgebreid met aggregaten, types, inductieve definities, parti\"{e}le functies, rekenkundige bewerkingen enz. maakt het beschrijven van problemen veel makkelijker. En hoewel de klasse van problemen die het ermee kan beschrijven niet groter wordt, maakt het de taak van het modelleren vaak gemakkelijker en is het mogelijk dat de klasse van problemen die opgelost kunnen worden wel groter wordt (vb. reachability problemen) \cite{denecker2008building}.

\citep{de2014minisat} is een vergelijkende studie tussen MiniSAT(ID) solver uit IDP en Gringo-Clasp. De laatste was de winnaar van de ASP wedstrijd in 2013 voor de categorie Model-and-Solve waar IDP als vierde eindigde. Voor sommige van de problemen werd IDP echter gediskwalificeerd door problemen met het modelleren. Daarom hebben de auteurs IDP opnieuw getest tegen de problemen van de wedstrijd en de resultaten vergeleken met die van Gringo-Clasp. De uitkomst tonen dat Gringo-Clasp meer instanties van de problemen heeft kunnen oplossen dan IDP en hier vaak ook minder tijd voor nodig had. Maar dit is volgens de auteurs te wijten aan de manier waarop de problemen gemodelleerd zijn. In IDP zijn modellen vaak simpel en minder probleem-specifiek dan bij Gringo-Clasp. Daar bestaan ze vaker uit veel meer regels en bevatten sommige modellen zelfs complexe optimalisatie regels voor bijvoorbeeld symmetry breaking. Voor problemen waar de modelleren gelijkaardig zijn liggen de resultaten zeer dicht bij elkaar. 

Deze vergelijkende studies zijn niet de enige positieve bewijzen van de kracht en voordelen van IDP. Het werk van \citep{vlaeminck2009logical} wijst net zoals \cite{gelle1996interactive} op de voordelen van een declaratieve aanpak. Maar deze resultaten zijn te wijten aan het gebruik van IDP. 

Wellicht de meest interessante case study is die van \citep{van2016kb} waar de auteurs een interactief configuratieprobleem van aanzienlijke schaal voor het consultancy bedrijf Active Planet beschrijven en oplossen met behulp van IDP. Opnieuw zijn de resultaten bevestigend en positief. De prestaties worden beoordeeld op basis van negen criteria voorgesteld in het boek van \citep{felfernig2014knowledge}. Deze zijn bedoeld om een beter beeld te geven van de prestaties van een configuratiesysteem. 
\begin{description}
\item[Graphical Modeling Concepts (C1)] Aanwezig als het systeem de mogelijkheid biedt om kennis over het domein te visualiseren met behulp van grafische technieken.
\item[Component Oriented Modeling (C2)] De taal waarmee de regels beschreven worden laat modellering toe van types, relaties, hi\"{e}rarchie etc.
\item[Automated Consistency Maintenance (C3)] Is opgedeeld in twee categorie\"{e}n, de eerste categorie is a priori consistency maintenance, oftewel controle op consistentie gedurende de ontwikkeling van de kennisbank. Vervolgens is er runtime consistency maintenance, waarbij de gebruiker ondersteund wordt gedurende het selectieproces door te garanderen dat in elke stap van het proces de selectie satisfieerbaar is.
\item[Modularization concepts are available (C4)] De taal is modulair in de zin dat constraints georganiseerd kunnen worden individuele blokken of groepen.
\item[Maintainability (C5)] De kennisbank kan gemakkelijk overweg met veranderingen in de regels, m.a.w. het bijwerken van de regels kost weinig moeite. 
\item[Model-based (C6)] De kennisbank drukt exact datgene uit dat nodig is voor een correcte configuratie. Niet zoals rule-based systemen, waarbij de regels pas vuren onder bepaalde voorwaarden die ook nog beschreven moeten worden.
\item[Efficiency (C7)] Houdt verband met de effici\"{e}ntie en schaalbaarheid van de solver.
\item[Ability to solve generative problem settings (C8)] De theorie is in staat om regels te beschrijven over een type component i.p.v. specifieke objecten.
\item[Ability to provide explanations (C9)] Het systeem kan verklaringen bieden voor foute selecties en uitleggen waarom bepaalde keuzes verboden of verplicht zijn.
\end{description}
De score op deze criteria wordt vergeleken met die van tien andere bekende systemen, en toont duidelijk dat IDP als \'{e}\'{e}n van de beste systemen uit de bus komt, waarbij het aan de meeste criteria voldoet. IDP voldoet niet aan \textbf{(C1)}, maar volgens \citep{van2016kb} maken de expressiviteit en leesbaarheid van de taal een grafische modellering van de kennis overbodig. 
A priori consistency maintenance \textbf{(C3)} is ondersteund, runtime consistency maintenance daarentegen is in theorie ondersteund maar door computationele beperkingen is het gebruik van benaderingen aangeraden hoewel deze niet dezelfde garanties hebben.
Effici\"{e}ntie \textbf{(C7)} is een moeilijk te meten factor, aangezien er geen standaard benchmark tests bestaan die hier uitsluitsel over kunnen geven. Voor het testprobleem van het onderzoek bleek de reactietijd weliswaar goed. En voorgaande tests in andere onderzoeken bevestigen prestaties gelijkaardig aan die van ASP solvers. 
Bovenop hun bevindingen wordt ook de opmerking gemaakt dat deze andere systemen specifiek rond \'{e}\'{e}n vorm van inferentie werken, terwijl IDP speciaal ontwikkeld is om meerdere vormen van inferentie toe te kunnen passen zonder het te moeten herschrijven van de kennis.

\section{Probleemstelling}
Een ISP samenstellen valt onder de categorie van Interactieve Configuratieproblemen. De gebruiker, in dit geval een toekomstige student, wil een geldig ISP bekomen d.m.v. het selecteren van mogelijke opleidingsonderdelen (vakken) voor de door hem/haar gekozen opleiding. Maar de student kan niet zomaar elk opleidingsonderdeel selecteren, er zijn een heleboel regels waaraan de selectie moet voldoen. Deze regels zijn op zichzelf duidelijk en intu\"{i}tief, maar een selectie vinden die aan alle regels voldoet kan mogelijk verwarrend zijn. Het huidige systeem, een web applicatie op de website van de universiteit (K.U. Loket) voorziet wel enige ondersteuning gedurende het selectieproces. De student kan simpelweg vakken selecteren door in vinkje te zetten in de checkbox dat bij een bepaald vak hoort, deze selectie kan ongedaan gemaakt worden door dit vinkje weer weg te klikken. Wanneer de student tevreden is met de selectie, kan hij/zij diens keuze bevestigen en het systeem zal dan controleren of de selectie voldoet aan de regels van het ISP. Is dit niet het geval dan wordt de student hiervan op de hoogte gebracht en wordt er uitleg (verklaring in natuurlijke taal) voorzien waarom ze niet klopt. Wat dit echter niet doet is aanwijzen welke combinatie van keuzes verantwoordelijk is voor deze fout. Mogelijke oplossingen worden ook niet voorzien door het systeem, dus hoewel de student wel weet wat er mis is, zal hij/zij zelf op zoek moeten gaan naar  de oorzaak en dit zien op te lossen. Het niveau van ondersteuning is op zich voldoende en iedere student zal uiteindelijk in staat zijn een geldig ISP samen te stellen, de regels zijn immers niet al te complex en de omvang van de opleidingen zijn redelijk beperkt. Het ontbreken van het lessenrooster is wellicht een grotere tekortkoming. Een student moet immers vakken selecteren zonder zeker te zijn of de lesmomenten niet overlappen. De lesmomenten voor ieder individueel vak zijn terug te vinden op de website van de K.U. Leuven, maar dit opzoeken is erg tijdrovend en ineffici\"{e}nt. Tenslotte maakt systeem van het K.U. Loket  gebruik van een imperatieve aanpak. /*KLOPT DIT?*/ De opleidingen aan de universiteit zijn niet statisch, ze veranderen regelmatig van samenstelling net zoals de regels die een geldig ISP bepalen. Het staat reeds vermeld dat een imperatieve aanpak niet goed overweg kan met deze frequente veranderingen en dat de implementatie kost van deze wijzigingen mogelijk groot is. 

\section{Doel}
Declaratieve systemen zijn beter geschikt voor het beschrijven van Interactieve configuratieproblemen zoals het samenstellen van een ISP. Kennis beschrijven over het probleem kan veel effici\"{e}nter. Deze kennis is trouwens veel overzichtelijker dan die van een imperatief systeem. Frequente veranderingen van de regels kunnen gemakkelijk aangepast worden, wat zeer voordelig is wanneer het op de regels van het ISP aankomt. 

In dit werk onderzoek ik de mogelijkheden van IDP met betrekking tot het oplossen van het ISP probleem. Hiervoor beperk ik mij tot een klein subdomein binnen de opleidingen, namelijk enkele opleidingen binnen de afdeling informatica. De bedoeling is om een theorie te ontwikkelen in FO(\textperiodcentered) die in staat is om voor deze opleidingen de geldige samenstellingen van het ISP te beschrijven. 

Het systeem van de K.U. Leuven biedt voldoende ondersteuning om zonder al teveel moeite een geldig ISP te kunnen samenstellen. Een interessante vraag is of een applicatie gebaseerd op IDP dezelfde of zelfs betere ondersteuning kan bieden. In een zelf ontworpen Front-end met grafische user interface is het de bedoeling om verscheidene functionaliteiten te integreren die de student bijstaan tijdens het selectieproces. De functionaliteiten zullen gebruik maken van verschillende inferentie technieken van het IDP systeem. Naast de functionaliteiten uit het bestaande systeem, zullen er ook nieuwe functionaliteiten ge\"{i}troduceerd worden. Hieronder staat een opsomming van alle functionaliteiten die deel uit zullen maken van de nieuwe front-end applicatie:
\begin{description}
\item[Automatisch invullen van gevolgen] Als de student tijdens het selectieproces keuzes maakt waaruit volgt dat sommige vakken ook geselecteerd moeten worden, dan zal het systeem deze automatisch invullen.
\item[Detectie van foutieve selectie] Tijdens het samenstellen van het ISP is het mogelijk dat de student keuzes maakt die ervoor zorgen dat de selectie nooit kan voldoen aan de regels. Het is dus de verantwoordelijkheid van het systeem om te detecteren of een selectie al dan niet tot een geldig samenstelling kan leiden of een geldige samenstelling is. Deze functionaliteit is momenteel al aanwezig in de huidige versie van het K.U. Loket, maar de detectie gebeurt pas op het moment dat de student de selectie bevestigt i.p.v. wanneer deze een nieuwe keuze maakt. Het is dat laatste dat ik wil bereiken in het nieuwe systeem.
\item[Foutieve selectie kunnen verklaren] Het kunnen detecteren van foutieve selecties en het verklaren ervan zijn twee verschillende taken. Als het systeem vaststelt dat een selectie ongeldig is, dan is het de bedoeling dat de student hiervan op de hoogte wordt gebracht en zowel uitleg krijgt over waarom dit zo is en hoe dit opgelost kan worden.
\item[Geldig ISP laten genereren] Stel dat een student keuzes heeft gemaakt omtrent de vakken die hij/zij echt wil of niet wil volgen, maar de selectie is nog geen volledige oplossing. Dan kan de student vragen aan het systeem om de selectie verder in te vullen.
\item[Optimaal ISP laten genereren] Niet alleen moet het systeem een geldige oplossing kunnen genereren, maar ook de beste oplossing volgens een bepaald criterium. Zo zou een student bijvoorbeeld graag een ISP willen waarbij de werklast zo goed mogelijk verdeeld is over beide semester. 
\item[Ongedaan maken van acties] Deze functionaliteit is terug te vinden in zowat de meeste moderne systemen. Als een student ontevreden is over zijn/haar recente keuzes, moet er de mogelijk zijn om deze ongedaan te kunnen maken. 
\item[Weergave van het lessenrooster] Zoals voorheen vermeld hebben studenten geen duidelijk overzicht van het lessenrooster dat voortvloeit uit hun keuzes. Vakken kunnen lesmomenten hebben die mogelijk overlappen met die van andere vakken en dit kan voor een ongewenste verrassing zorgen eens het ISP bevestigd is. Het is mijn bedoeling om in de nieuwe front-end wel een eventueel lessenrooster weer te geven.
\end{description}
De meeste van deze functionaliteiten steunen op inferentie technieken die IDP aanbiedt zoals model expansie, minimizatie, propagatie etc.. Dit wil zeggen dat om deze functionaliteiten te kunnen aanbieden, de onderliggende inferentie technieken effici\"{e}nt moeten werken. Herinner dat we te maken hebben met een IC probleem en dit vereist dat de reactietijd niet meer dan enkele seconden bedraagt. Onderzoek zal dus moeten uitwijzen of inferentie snel verloopt voor dit probleem.

\subsection{Conflict Explanation}
Een van de functionaliteiten die deel uit maakt van de front-end is het kunnen voorzien van een verklaring in geval van een foutieve selectie. Dit valt onder het domein van conflict explanation en IDP voorziet hiervoor twee technieken, de unsatstructure en de unsattheory. De eerste methode zoekt naar een precisie minimale subset binnen de selectie waarvoor geldt dat ze nooit uitgebreid kan worden tot een geldig model. Het spoort met andere woorden de oorzaak van het conflict op. De unsattheory daarentegen gaat op zoek naar een minimale set van regels uit de theorie die gegeven de selectie nooit waar gemaakt kunnen worden. Probleem met deze techniek is echter dat de output geformuleerd is in FO(\textperiodcentered) en ondanks de goede leesbaarheid zal een doorsnee gebruiker zonder gepaste achtergrond hier niets uit kunnen afleiden. Er moet dus een ander formaat bestaan dat door het systeem gegeven kan worden dat de gebruiker wel kan begrijpen. 

\paragraph{Reified Constraints}
Een interessante toevoeging is de techniek van Reified Constraints, een implementatie die het mogelijk maakt om verklaringen te kunnen geven waarom een selectie fout is geformuleerd in natuurlijke taal. De techniek zoekt net zoals de unsattheory naar een minimale set van regels die nooit samen waar kunnen zijn gegeven de structuur, maar i.p.v. de regels uit te drukken in FO(\textperiodcentered) is de output de set van indices die aan de regels vast zitten. Deze indices kunnen vervolgens gebruikt worden om een vooraf beschreven verklaring in natuurlijke taal te kunnen opzoeken. De inferentie taken die nodig zijn om deze techniek mogelijk te maken allemaal deel uit van het IDP systeem en externe systemen zijn dus niet nodig. Onderzoek zal moeten uitwijzen hoe goed deze implementatie werkt voor het ISP probleem, m.a.w. hoe duidelijk de verklaringen zijn en hoe nuttig deze zijn voor de gebruiker. Een gedetailleerde uitleg van de implementatie is terug te vinden in \ref{sec:reifiedconstraints}.

\paragraph{Eindige toestandsautomaten en CSP's}
Naast verklaringen in natuurlijke taal, is een interessante vorm van conflict explanation het kunnen geven van oplossingen. Met oplossingen wordt bedoeld minimale subsets uit de huidige selectie die ongedaan gemaakt dienen te worden zodanig dat de selectie terug uitgebreid kan worden tot een geldig model. Een methode die effici\"{e}nte ondersteuning voor deze taak biedt is in IDP niet volledig aanwezig. In het werk van \citep{amilhastre2002consistency} wordt gebruik gemaakt van een eindige toestandsautomaat, een implementatie waarmee het zoeken naar zulke oplossingen wel mogelijk is. De focus van het Amilhastre's werk ligt op het reduceren van de complexiteit van inferentie methoden binnen het domein van interactieve configuratieproblemen. In de klasse van IC problemen is het belangrijk dat de reactietijd van de inferentie technieken laag ligt. Het probleem is echter dat IC problemen net zoals CSP's enorm complex zijn, wat maakt dat sommige inferentie technieken intractable (onhandelbaar) zijn in het slechtste geval. \citep{vempaty1992solving} stelt in zijn werk voor om Constraint Satisfaction Problems voor te stellen door geminimaliseerde deterministische eindige toestandsautomaten (MDFA), een compactere weergave van de oplossingsverzameling, en stelt dat eens ze gebouwd zijn, inferentie taken zoals het controleren van satisfieerbaarheid, model expansie en query checking triviaal worden. \citep{amilhastre2002consistency} bouwt verder op hetzelfde principe en kiest opnieuw voor het gebruik van MDFA's, maar dan in de context van interactieve configuratieproblemen. Door gebruik te maken van de automaat stelt Amilhastre dat niet enkel de inferentie taken uit Vempaty's werk voor CSP's computationeel haalbaar worden, maar dit ook uitgebreid kan worden tot bepaalde inferentie taken binnen het domein van IC problemen. Dit is natuurlijk een groot voordeel in een klasse van problemen waar de reactietijd van de bewerkingen laag moet liggen. De complexiteit van de bewerkingen worden verschoven naar een a priori compilatie fase, die slechts \'{e}\'{e}nmaal uitgevoerd hoeft te worden. Eens de automaat gebouwd is kan ze op eender welk moment gebruikt worden om at runtime, en garandeert ze een aanzienlijke verlaging van de complexiteit van bepaalde inferentie taken namelijk controleren op satisfieerbaarheid, het zoeken naar minimale oplossingen (in geval van een niet-satisfieerbare selectie) en het voorzien van restauraties. Onderzoek zal moeten uitwijzen of de techniek van Amilhastre gecombineerd kan worden met het IDP systeem, en of het mogelijk een automaat te genereren met behulp van IDP zodanig dat deze kan gebruikt worden om oplossingen te kunnen voorzien voor de gebruiker.

\section{Dependencies}
\begin{description}
\item [FO(\textperiodcentered)] De taal FO(\textperiodcentered) is eerste orde logica met de toevoeging van een aantal extensies. Momenteel bevat het de volgende extensies:
\begin{itemize}
\itemsep0em
\item Types
\item Inductieve definities
\item Aggregaten
\item Aritmetiek
\item Parti\"{e}le functies
\end{itemize}
De combinatie van eerste orde logica met deze extensies laat toe om problemen op een z\'{e}\'{e}r compacte en overzichtelijke manier te beschrijven. De syntax van FO(\textperiodcentered) oogt zeer natuurlijk, wat het begrijpen van deze regels vergemakkelijkt voor de ontwikkelaar. 
\item [Python] De front-end applicatie is volledig ontwikkeld in python. De grafische interface van de front-end is gebaseerd op de python Kivy library, een framework dat speciaal toegewijd is aan de ontwikkeling van cross-platform applicaties. Het biedt aan uitgebreid gamma aan GUI elementen die z\'{e}\'{e}r configureerbaar zijn. Kivy ondersteund een zelf ontwikkelde taal genaamd kv-language die toelaat om GUI elementen gemakkelijker te configureren. 
\item [JSON] Informatie over de structuur en samenstelling van verschillende opleidingen wordt beschreven m.b.v. JSON. Het gegevensformaat van JSON laat toe om deze structuur in een effici\"{e}nte, structurele en compacte manier te beschrijven. 
\end{description}