\chapter{Introduction}
\label{cha:intro}

\subsection{Constraint Satisfaction Problems}
CSP's zijn van het type problemen waar men voor een reeks variabelen een geldige waarde uit het domein dient toe te kennen. De toekenning echter is gebonden aan een set van regels waaraan de variabelen moeten voldoen. Formeel defini\"{e}ren we een CSP als een triple $\langle \mathcal{X},\mathcal{D},\mathcal{C} \rangle$, met $\mathcal{X}$ de verzameling van variabelen, $\mathcal{D}$ de domeinwaarden voor deze variabelen en $\mathcal{C}$ de constraints over de variabelen. Typisch worden dit soort problemen opgelost d.m.v. zoeken door alle mogelijk combinaties, deze recursieve methode gaat voor elke nieuwe toekenning na of de constraints voor de parti\"{e}le toekenning consistent zijn. Zo ja, dan volgt er een nieuwe recursieve oproep, anders gaat het algoritme backtracken. Het oplossen van CSP's met een eindig domein valt in de klasse van NP-Compleet problemen met betrekking tot de grootte van het domein. Om het zoekproces proberen te versnellen bestaan er variaties op backtracking zoals backmarking en backjumping. De eerste zorgt voor een effici\"{e}ntere manier om consistentie na te gaan en backjumping is een betere manier van backtracking waarbij men over meerdere waarden tegelijk kan backtracken. Deze technieken versnellen het zoekproces in dat ze onnodige stappen detecteren en overslaan. Anderzijds bestaan er propagatie technieken die lokale consistentie garanderen met technieken zoals arc consistency, hyper-arc consistency en path-consistency die de domeinen van de variabelen proberen te verkleinen alvorens het zoekproces gestart wordt. 


\subsection{Interactive Configuration Problems}
In deze thesis ligt de focus op een specifieke groep van problemen binnen het domein van CSP's genaamd Interactieve Configuratie (IC) problemen. Constraint Satisfaction Problems zijn problemen waar men een toekenning van domeinwaarden voor de variabelen wil zoeken waarvoor geldt dat aan alle constraints voldaan is. Bij IC problemen wil men exact hetzelfde bekomen maar waar men voorheen recursief ging zoeken naar zo'n oplossing is het nu een gebruiker die handmatig stap per stap een geldige toekenning gaat proberen selecteren. Om de gebruiker hierin bij te staan is er nood aan software, software die de gebruiker zo goed mogelijk bijstaat gedurende dit hele proces. Men weet uit ervaring dat het schrijven van software voor dit soort problemen geen gemakkelijke opgave is. Regels ontwikkelen voor kleine problemen zoals het n-queen probleem zijn intu\"{i}tief en gemakkelijk. Maar naarmate de problemen groter en complexer worden zal het als maar moeilijker worden om dit in software om te zetten. Verder is aangetoond dat een imperatieve aanpak voor het beschrijven van de regels van een probleem vaak moeilijk is \citep{gelle1996interactive}. Reden hiervoor is dat de regels over de betreffende domeinkennis vaak verspreid zit in de software in codesnippets. Daarboven is onderhoud van zulke software een enorm moeilijke opgave waarbij de kleinste wijziging in de constraints kan leiden tot een volledige herwerking van de code. Daarom is men op zoek gegaan naar alternatieven en het antwoord kwam uit de declaratieve hoek. Met de opkomst van declaratieve programmeertalen, vooruitgang in automated reasoning en als maar toenemende rekenkracht van computersystemen is de populariteit van declaratieve toepassingen alleen maar gegroeid. In declaratieve toepassingen kan men de regels van een probleem beschrijven d.m.v. logische constraints. Wellicht het grootste voordeel van declaratieve methoden in tegenstelling tot imperatieve is dat de regels overzichtelijker en duidelijker zijn. Onderhoud van deze constraints is veel makkelijker, als er een regel wijzigt dan hoeft ook enkel deze constraint aangepast te worden. En hoewel men met een imperatieve aanpak optimalere algoritmen kan ontwikkelen, heeft men kunnen laten zien dat declaratieve methoden ook goede prestaties kunnen neerzetten \citep{vlaeminck2009logical}. 

\subsection{Knowledge Representation: Het IDP Systeem}
De interesse in declaratieve talen is de laatste decennia toegenomen en als resultaat zijn er een hele resem talen verschenen (Prolog, Ant, Lisp, ...). Wat opvalt is dat elke taal vaak samenhangt met \'{e}\'{e}n enkele specifieke vorm van inferentie. En toch is ondanks de verschillende vormen van inferentie de kennis over het domein hetzelfde. Enkele jaren geleden heeft men het concept van Knowledge Representation \citep{denecker2008building} voorgesteld. In het KR-paradigma stelt men dat ongeacht de inferentie die men wil toepassen, men hiervoor telkens dezelfde kennis kan hergebruiken. Deze kennis is niets meer dan een verzameling van informatie, maar met deze informatie kan men meerdere vormen van inferentie toepassen. In dit onderzoek ligt de aandacht op IDP, een KR-systeem ontwikkeld aan de K.U. Leuven en voor het eerst voorgesteld in 2008. Het laat toe om de kennis over een probleem te beschrijven in FO(\textperiodcentered), dit is eerste orde logica maar uitgebreid met aggregaten, type definities en inductieve definities. Met deze kennis kan men dan meerdere vormen van inferentie doen. 

\section{Probleemstelling}

\subsection{Individueel Studieprogramma}
Een ISP samentstellen valt onder deze categorie van Interactieve Configuratieproblemen. De gebruiker, in dit geval een toekomstige student wil een geldig ISP bekomen d.m.v. het selecteren van mogelijke opleidingsonderdelen. Maar de student kan niet zomaar elk opleidingsonderdeel selecteren, er zijn een heleboel regels waaraan de selectie moet voldoen. Deze regels zijn op zichzelf duidelijk en intu\"{i}tief, maar om een selectie vinden die aan alle regels voldoet kan mogelijk verwarrend zijn. Het huidige systeem voorziet weinig ondersteuning in het bijstaan van de gebruiker gedurende het selectieproces. Het is pas als je een selectie bevestigt dat het systeem controleert of deze ook effectief correct is volgens de regels. En hoewel het systeem wel weergeeft aan welke regels er (in geval van inconsistentie) niet voldaan is, moet de gebruiker zelf op zoek gaan naar de selectie die verantwoordelijk is verantwoordelijk is hiervoor. De regels van een geldig ISP nemen geen lessenrooster in acht, wat dus betekent dat lesmomenten voor verschillende opleidingsonderdelen kunnen overlappen. 

\section{Doel}
In deze thesis wil ik gaan onderzoeken of de regels van het ISP effici\"{e}nt kunnen beschreven worden in FO(\textperiodcentered). De regels zijn voor elke opleiding anders. Men kan dan de vraag stellen of het mogelijk is om met \'{e}\'{e}n enkele theorie in IDP alle opleidingen correct te kunnen beschrijven. Belangrijk hierbij is dat de domeinen sterk kunnen verschillen tussen opleidingen, en dat de eventuele theorie hier mee om moet kunnen gaan. 

Een minpunt van het huidige systeem is de minimale ondersteuning die het biedt tijdens het selectieproces. Hier kan beter gedaan worden, daarom wil ik meer ondersteuning proberen bieden. In een zelf ontworpen Front-end met grafische user interface wil ik de volgende functionaliteiten integreren:
\begin{description}
\item[Automatisch invullen van gevolgen] Als de student een vak A kiest en hieruit volgt dat vak B ook gevolgt moet worden, dan is het de bedoeling dat het systeem dit automatisch invult zodat de student zich hier verder niets van hoeft aan te trekken. 
\item[Detectie van foutieve selectie] Deze functionaliteit is momenteel al aanwezig in het huidige systeem. Maar de detectie gebeurt pas bij de bevestiging van de selectie i.p.v. op het moment van de selectie zelf. En dat is wat ik zal proberen te integreren in de nieuwe front-end. En niet enkel dit, maar ook het effectief opsporen van de oorzaak zodat de gebruiker dit kan aanpassen.
\item[Geldig ISP laten genereren] Stel dat een student keuzes heeft gemaakt omtrend de vakken die hij/zij echt wil of niet wil volgen, maar de selectie is nog geen volledige oplossing. Dan kan de student vragen aan het systeem om de selectie verder in te vullen.
\item[Optimaal ISP laten genereren] Niet alleen moet het systeem een geldige oplossing kunnen genereren, maar ook de beste oplossing volgens een bepaalde criterium. Zo zou een student bijvoorbeeld graag een ISP willen waarbij de werklast zo goed mogelijk verdeeld is over beide semester. 
\item[Ongedaan maken van acties] Deze functionaliteit is terug te vinden in zowat de meeste moderne systemen. Als een student ontevreden is over zijn/haar recente keuzes, moet er de mogelijk zijn om deze ongedaan te kunnen maken. 
\item[Weergave van het lessenrooster] Voorheen had ik al vermeld dat studenten geen duidelijk overzicht hebben van het lessenrooster dat voortvloeit uit hun keuzes. Vakken kunnen lesmomenten hebben die mogelijk overlappen met die van andere vakken en dit kan voor een ongewenste verrassing zorgen eens het ISP bevestigd is. Het is mijn bedoeling om in de nieuwe front-end wel een eventueel lessenrooster weer te geven.
\end{description}
De meeste van deze functionaliteiten steunen op inferentie technieken die IDP aanbeidt zoals model expansie, minimizatie, propagatie etc. Dit wil zeggen dat om deze functionaliteiten te kunnen aanbieden, de onderliggende inferentie technieken effici\"{e}nt moeten werken. Herinner dat we te maken hebben met een IC probleem en dit vereist dat de reactietijd niet meer dan enkele seconden bedraagt. Ik zal dus moeten onderzoeken of inferentie goed verloopt binnen dit probleem.

Het opsporen van foutieve selecties is \'{e}\'{e}n ding, maar kunnen \emph{verklaren} wat er mis is met de selectie is een ander verhaal. 
Het domein van Conflict explanation bevat nog een heel aantal openstaande vragen. IDP zelf voorziet zelf de unsatcore, en methode die opzoek gaat naar de regels die (in geval van unsatisfiability) nooit waar gemaakt kunnen worden. Probleem is echter dat de output geformuleerd is in FO(\textperiodcentered), en een doorsnee gebruiker zal niet in staat zijn om hieruit iets te kunnen afleiden. Verscheidene andere technieken voor conflict explanation die zijn voorgelegd leggen de focus op het optimaliseren van de rekentijd \citep{amilhastre2002consistency} of het zoeken naar minimale correcties \citep{o2005generating}. Maar in verklaring geven in een formaat dat begrijpbaar is voor iedereen, daarvoor bestaat nog geen algemene techniek. En in deze thesis zet ik een stap in het ongewisse om op zoek te gaan naar oplossing.


\section{Dependencies}
\begin{description}
\item [FO(\textperiodcentered)] Het is de bedoeling om de mogelijkheden van IDP in actie te zien en met een proof of concept de prestaties van het systeem te testen. FO(\textperiodcentered) bezit een grote uitdrukkingskracht, bovenop eerste order logica bevat het ook taalelementen zoals aggregaten (sum, avg, min, max, ..) en inductieve definities. 
\item [Kivy] Bij de keuze van de programmeertaal en framework viel mijn oog op Kivy. Dit is een Python library met een hele waaier aan grafische elementen die elk uitgebreid geconfigureert kunnen worden. Hiervoor kan gebruik gemaakt worden van een door de uitgever ontwikkelde kv-language. Kivy applicaties werken cross-platform en de applicaties zijn event-driven gebruik makend van een centrale loop.
\item [JSON] Het gegevensformaat van JSON is ideaal om de domeinen van verschillende opleidingen in weer te geven. De domeinwaarden zitten gekoppeld aan een attribuut, dit maakt het gemakkelijk om structuur te parsen en zo het domein voor iederen opleiding in te lezen.
\end{description}