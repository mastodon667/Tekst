\chapter{Introduction}
\label{cha:intro}

\subsection{Constraint Satisfaction Problems}
CSP's zijn van het type problemen waar men voor een reeks variabelen een geldige waarde uit het domein dient toe te kennen. De toekenning echter is gebonden aan een set van regels waaraan de variabelen moeten voldoen. Formeel defini\"{e}ren we een CSP als een triple $\langle \mathcal{X},\mathcal{D},\mathcal{C} \rangle$, met $\mathcal{X}$ de verzameling van variabelen, $\mathcal{D}$ de domeinwaarden voor deze variabelen en $\mathcal{C}$ de constraints over de variabelen. Typisch worden dit soort problemen opgelost d.m.v. zoektechnieken waarbij de solver itereert over alle domeinwaarden binnen het eindige domein met de bedoeling om een uiteindelijke invulling te vinden voor alle variabelen de voldoet aan alle constraints. Vaak is het zo dat CSP's van een hoge complexiteit zijn en om het zoekproces zoveel mogelijk te versnellen maakt men gebruik van geavanceerde zoektechnieken en heuristieken.  

\subsection{Interactive Configuration Problems}
In deze thesis ligt de focus op een specifieke groep van problemen binnen het domein van CSP's genaamd Interactieve Configuratie (IC) problemen. Constraint Satisfaction Problems zijn problemen waar een bepaalde configuratie van objecten wilt bekomen zodanig dat ze voldoen aan een set van regels. IC problemen zijn in essentie CSP's, het verschil is dat ze interactief opgelost dienen te worden terwijl men bij CSP's een oplossing laat zoeken. Een gebruiker stelt stapsgewijs een configuratie samen die uiteindelijk consistent is met alle constraints. Men weet uit ervaring dat het schrijven van software voor dit soort problemen geen gemakkelijke opgave is. Regels ontwikkelen voor kleine problemen zoals het n-queen probleem zijn intu\"{i}tief en gemakkelijk. Maar naarmate de variabelen, domeinwaarden en regels toenemen zal het als maar moeilijker worden om dit in software om te zetten. Verder is aangetoond dat een imperatieve aanpak inherent moeilijk is \citep{gelle1996interactive}. Reden hiervoor is dat de regels over de betreffende domeinkennis vaak verspreid zit in de software in codesnippets. Daarboven is onderhoud van zulke software een enorm moeilijke opgave waarbij de kleinste wijziging in de constraints kan leiden tot een volledige herwerking van de code. Daarom is men op zoek gegaan naar alternatieven, en het antwoord kwam uit de declaratieve hoek. Met de opkomst van declaratieve programmeertalen, vooruitgang in automated reasoning en als maar toenemende rekenkracht van computersystemen is de populariteit van declaratieve toepassingen alleen maar gegroeid. In declaratieve toepassingen kan men de regels van een probleem beschrijven d.m.v. logische constraints. De solver gebruikt deze constraints vervolgens om te zoeken naar een geldige oplossing. Wellicht het grootste voordeel van declaratieve methoden in tegenstelling tot imperatieve is dat de regels overzichtelijk en duidelijk. Onderhoud van deze constraints is veel makkelijker, als er een regel wijzigt dan hoeft ook enkel deze constraint aangepast te worden. En hoewel men met een imperatieve aanpak optimalere algoritmen kan ontwikkelen, heeft men kunnen laten zien dat declaratieve methoden ook goede prestaties kunnen neerzetten \citep{vlaeminck2009logical}. 

\subsection{Knowledge Representation: Het IDP Systeem}
De interesse in declaratieve talen is de laatste decennia toegenomen en als resultaat zijn er een hele resem talen verschenen (Prolog, Ant, Lisp, ...). Wat opvalt is dat elke taal vaak samenhangt met \'{e}\'{e}n enkele specifieke vorm van inferentie. En toch is ondanks de verschillende vormen van inferentie de kennis over het domein hetzelfde. Enkele jaren geleden heeft men het concept van Knowledge Representation \citep{denecker2008building} voorgesteld. In het KR-paradigma stelt men dat ongeacht de inferentie die men wil toepassen, men hiervoor telkens dezelfde kennis kan hergebruiken. Deze kennis is niets meer dan een verzameling van informatie, maar met deze informatie kan men meerdere vormen inferentie toepassen. 

\section{Probleemstelling}

\subsection{Individueel Studieprogramma}
Een ISP samentstellen valt onder deze categorie van Interactieve Configuratieproblemen. De gebruiker, in dit geval een toekomstige student wil een geldig ISP bekomen d.m.v. het selecteren van mogelijke opleidingsonderdelen. Maar de student kan niet zomaar elk opleidingsonderdeel selecteren, er zijn een heleboel regels waaraan de selectie moet voldoen. Deze vari\"{e}ren naargelang de gekozen opleiding en het is al eens mogelijk dat de student in de war kan geraken en een foute selectie maakt en deze fouten komen pas boven water zodra de student zijn/haar keuze bevestigt. Naast al deze regels moet er ook nog rekening gehouden worden met het lessenrooster. Het is mogelijk dat lesmomenten voor verschillende opleidingsonderdelen overlappen met elkaar. Het probleem is echter dat de student hier niet van op de hoogte wordt gebracht noch een overzicht heeft. 

\section{Doel}
In deze thesis willen we onderzoeken of de regels van het ISP effici\"{e}nt kunnen beschreven worden in FO(\textperiodcentered). Met de bedoeling dat voor eender welke opleiding binnen de K.U. Leuven deze set van regels een geldige opleiding kunnen beschrijven. 

Vervolgens willen we kijken of we met deze theorie verschillende vormen van inferentie kunnen doen en hoe efficient deze gebeuren. Met behulp van een zelf ontworpen front-end (incl. grafische interface) willen we nagaan of de gebruiker een geldig ISP kan selecteren, kan laten samenstellen enz. En of al deze functionaliteiten in real-time kunnen uitgevoerd worden met een reactietijd van maximaal enkele seconden. 

Momenteel wordt het lessenrooster niet in acht genomen tijdens het selectieproces. Dit wil zeggen dat de student dus ook geen idee heeft of de door hem/haar geselecteerde opleidingsonderdelen mogelijk lesmomenten bevatten die overlappen. Hier is het de bedoeling om de gebruiker een overzicht te geven van het lessenrooster voor elke stap in het selectieproces. En daarboven het beste lessenrooster te laten genereren waarbij er zo weinig mogelijk overlappende lessen zijn.

In het geval van een ongeldige selectie biedt IDP een aantal mogelijkheden om aan de gebruiker duidelijk te maken wat er juist mis is gegaan. De \emph{unsatcore} zoekt naar de minimale set van regels die ongeldig zijn voor de huidige selectie. Een andere optie is de \emph{unsatstructure} die de kleinste set van variabelen wordt gezocht waarbij als men de geselecteerde waarden voor deze variabelen ongedaan maakt, de selectie niet langer ongeldig is. Maar om een duidelijk verklaring te verkrijgen waarom de selectie fout is, in een formaat dat elke persoon kan begrijpen bestaat er in IDP momenteel nog niets. Daarom willen we onderzoeken of we dit kunnen realiseren.

\section{Dependencies}
\begin{description}
\item [FO(\textperiodcentered)] Het is de bedoeling om de mogelijkheden van IDP in actie te zien en met een proof of concept de prestaties van het systeem te testen. FO(\textperiodcentered) bezit een grote uitdrukkingskracht, bovenop eerste order logica bevat het ook taalelementen zoals aggregaten (sum, avg, min, max, ..) en inductieve definities. 
\item [Kivy] Bij de keuze van de programmeertaal en framework viel mijn oog op Kivy. Dit is een Python library met een hele waaier aan grafische elementen die elk uitgebreid geconfigureert kunnen worden. Hiervoor kan gebruik gemaakt worden van een door de uitgever ontwikkelde kv-language. Kivy applicaties werken cross-platform en de applicaties zijn event-driven gebruik makend van een centrale loop.
\item [JSON] Het gegevensformaat van JSON is ideaal om de domeinen van verschillende opleidingen in weer te geven. De domeinwaarden zitten gekoppeld aan een attribuut, dit maakt het gemakkelijk om structuur te parsen en zo het domein voor iederen opleiding in te lezen.
\end{description}