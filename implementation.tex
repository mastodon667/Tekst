\chapter{Implementation}
\label{cha:implementation}

\subsection{Preliminaries}
De kennis over het ISP staat beschreven in een theorie T over een vocabularium $\Sigma$. Dit vocabularium bestaat uit een set $\Sigma\textsubscript{p}$ van predicaatsymbolen en een set van functiesymbolen $\Sigma\textsubscript{f}$. Een interpretatie I bestaat uit D de verzameling domeinelementen, een mapping van elk functiesymbool f/n naar een functie met ariteit n op D en een mapping van elk predicaatsymbool P/n naar een relatie R $\subseteq$ D$\textsuperscript{n}$. Een three-valued parti\"{e}le interpretatie bestaat uit een mapping op drie waarheidswaarden {u,t,f} respectievelijk onbekend, waar en niet waar. De waarheidswaarden zijn partieel geordend volgens precisie, u $\leq\textsubscript{p}$ f en u $\leq\textsubscript{p}$ t. De bedoeling is om een exacte interpetatie te bekomen met maximale precisie die consistent is met de theorie T.

\section{Knowledge base constructie}
Geen opleiding aan de KU Leuven is dezelfde, de opleidingsonderdelen verschillen net zoals de vakgroepen waar ze deel van uitmaken. Voor sommige vakgroepen ben je verplicht alle onderdelen op te nemen, terwijl je voor andere en minimaal (of zelfs maximaal) aantal studiepunten ervan moet opnemen. Kortom de regels binnen \'{e}\'{e}nzelfde opleiding zijn niet zo moeilijk om te beschrijven, maar om dit te veralgemenen en een theorie te cre\"{e}ren die voor alle opleidingen een geldig ISP kan beschrijven dat is een andere paar mouwen. Voor het gemak van de lezer noemen we opleidingsonderdelen vanaf nu vakken. Hieronder staan de verschillende onderdelen van de knowledge base beschreven.

\subsection{Vocabulary}
Om te beginnen zal ik de vocabulair toelichten, beginnend bij de types waarna ik de functies en predicaten zal beschrijven.
\begin{description}
\item [Vak] De naam verklaart zichzelf al, dit type omvat de verzameling van de verschillende vakken in het domein. 
De domeinwaarden zijn niet de naam in natuurlijke taal, maar de unieke vakcode.
\item [VakNaam] Elk vak heeft een naam geschreven in natuurlijke taal oftwel de vaknaam.
\item [VakGroep] Vakgroepen zijn een heel algemeen concept, het omvat elke verzameling van vakken waarvoor bepaalde regels gelden. Per groep gelden er andere regels die uniek zijn voor die groep, maar ook het type waartoe de groep behoort.
\item [VakGroepType] Elke vakgroep maakt deel uit van een bepaald type groep, en per type groep gelden er bepaalde regels bovenop de regels van de individuele groep zelf.
\item [Fase] Opleidingen bestaan uit fases oftewel jaren, de Master Computer Wetenschappen bestaat bijvoorbeeld uit 2 fases. Vakken binnen een opleiding kunnen enkel gevolgd worden tijdens de fase van de opleiding waartoe ze behoren. 
\item [Semester] De K.U. Leuven werkt met een semester systeem, dit wil zeggen dat elke fase (schooljaar) is opgedeeld in 2 semesters. Elk vak kan gevolgd worden in de semester waartoe het behoort. Er bestaan ook jaarvakken waarvoor de werklast verdeeld is tussen beide semesters, een voorbeeld hiervan is de Masterproef.
\item [Studiepunten] Elk vak bevat studiepunten, deze beschrijven de geschatte werklast voor dit vak. Vakgroepen vereisen vaak dat je een bepaalde hoeveelheid een studiepunten opneemt. 
\end{description}

\begin{description}
\item [IsType(VakGroep,VakGroepType)]
\item [Verplicht(Vak,VakGroep)]
\item [InVakGroep(Vak,VakGroep)]
\item [InFase(Vak,Fase)]
\item [Geselecteerd(Vak,Fase)]
\item [NietGeselecteerd(Vak)]
\end{description}

\begin{description}
\item [HeeftNaam(Vak):VakNaam]
\item [MinAantalStudiepunten(VakGroep):Studiepunten]
\item [MaxAantalStudiepunten(VakGroep):Studiepunten]
\item [AantalStudiepunten(Vak):Studiepunten]
\item [GeselecteerdAantalStudiepuntenPerVakGroep(Vakgroep):Studiepunten]
\item [GeselecteerdAantalStudiepuntenPerSemester(VakGroep):Studiepunten]
\item [InSemester(Vak):Semester]
\end{description}

\subsubsection{Vakgroeptypes}
Zo valt op dat we telkens dezelfde \textbf{types} van \emph{vakgroepen} tegenkomen. Deze types die steeds terugkomen in meerdere opleidingen hebben ongeacht de opleiding waar ze in voorkomen dezelfde regels die ermee gepaard gaan. Zo is elke opleiding op zich een vakgroep van het type \emph{opleiding}, het bevat vakken die je verplicht bent te volgen en keuzevakken. Het heeft een minimum (en maximum) aantal studiepunten dat de student verplicht moet opnemen. Een ander belangrijk type vakgroep is de (hoofd)specialisatie, verscheidene opleidingen geven de keuze tussen meerdere specialisaties. Verwacht wordt dat je van minstens 1 zo'n specialisatie alle verplichte vakken opneemt. Naast hoofdspecialisatie bestaat er ook het type verdere specialisatie, waarin de student verplicht wordt een bepaald aantal studiepunten op te nemen aan vakken uit deze of bepaalde andere vakgroepen. Vervolgens is er het type 'Algemeen vormende en onderzoeksondersteunende groep' vakgroep, dit is veruit het moeilijkste type groep om te beschrijven. De student moet opnieuw een bepaald aantal studiepunten aan vakken opnemen uit deze groep. Maar daarnaast gelden er ook specifieke regels voor verscheidene vakken die deel uitmaken ervan. En als laatse is er het type 'Bachelor verbredend pakket', waarin studenten die beginnen aan hun masteropleiding vakken moeten opnemen die ontbraken in hun bacheloropleiding.

Deze types zien we het vaakst voorkomen en kunnen ongeacht de opleiding met dezelfde set van regels beschreven worden. Het is mogelijk dat sommige types van vakgroepen niet telkens voorkomen, en dus de regels ook niet van kracht zijn. In een bacheloropleiding zal bijvoorbeeld nooit een vakgroep voorkomen van het type Bachelor verbrendend pakket. 

\subsection{Theorie van het lessenrooster}



\section{Front-End}
Herinner dat het samenstellen van het ISP een Interactief configuratieprobleem is, en om aan de eigenschappen van zo'n IC probleem te kunnen voldoen moet de reactietijd van de inferentiemethoden snel genoeg zijn. Om dit te testen heb ik een front-end applicatie ontwikkeld die met behulp van een grafische interface een student toelaat een ISP samen te stellen. Deze input wordt vertaald naar FO(\textperiodcentered) en doorgespeeld naar IDP. Vervolgens voert IDP inferentie uit en de resultaten hiervan worden terug doorgespeeld naar de front-end, die het resultaat zal weergeven d.m.v. de GUI. Zo kunnen de prestaties van IDP in een gebruiksvriendelijke omgeving getest worden. 

\subsection{Grafische Gebruikersinterface}



\subsection{Communicatie tussen Front- en Back-end}
Niet alleen is de syntax tussen IDP en Python compleet verschillend, het zijn ook twee verschillende klassen van programmeertalen respectievelijk declaratief en objectgeori\"{e}nteerd. Dus communicatie tussen de twee talen is niet vanzelfsprekend. Een Python API die toelaat IDP te gebruiken is reeds ontwikkeld \citep{vennekens2015lowering}. Het doel van de API is om de kloof tussen de declaratieve omgeving van IDP en Python kleiner te maken. Door een populaire programmeertaal te kiezen hoopt de auteur dat informatici met een achtergrond in declaratieve talen sneller van IDP gebruik zullen maken hoewel ze de syntax van IDP niet meester zijn. Persoonlijk heb ik wel al ervaring met IDP en heb dus geopteerd om geen gebruik te maken van de API. 

De input/output van IDP is compleet tekstueel, de front-end moet een volledig tekst-bestand genereren in een formaat dat IDP kan begrijpen en verwerken. De output van IDP is opnieuw een tekst-bestand dat de front-end zal moeten parsen om het resultaat te kunnen verwerken. Zo'n tekst-bestand heeft altijd dezelfde opmaak, het bevat een theorie, vocabulair, structuur, procedure en eventueel termen in geval van minimizatie. De front-end bevat een parser object dat voor elke oproep zo'n tekst bestand zal opbouwen. De theorie, vocabularium en de procedures zijn altijd dezelfde en hoeven slecht \'{e}\'{e}nmalig ingelezen te worden. Enkel de structuur zal bij elke nieuwe actie gedeeltelijk dynamische gegenereerd moeten worden. De predicaten in het vocabularium zijn opgedeeld in twee verzamelingen. De eerste verzameling $\Gamma$ bevat de predicaten die vooraf gegeven zijn en gekend zijn door het systeem. Anders gezegd bestaat er een interpretatie G voor $\Gamma$. De andere verzameling $\Omega$, zijn de predicaten waar nog geen interpretatie W voor gegeven is en die door de gebruiker (in dit geval de student) ingevuld zullen moeten worden. Tot deze laatste groep behoren volgende predicaten: Geselecteerd(Vak,Fase) en NietGeinteresseerd(Vak). De bedoeling is om een invulling te zoeken zodat W $\cup$ G consistent is met alle regels van de theorie T.


\section{Features}

\subsection{Selectieproces}
Elke keuze die de gebruiker maakt moet zorgvuldig afgehandeld worden om te kunnen geranderen dat de selectie altijd satisfieerbaar is. De voorwaarde is dat als de gebruiker een keuze maakt die ervoor zorgt dat de theorie niet langer satisfieerbaar is, hij hier meteen op de hoogte van wordt gebracht zodanig dat hij dit kan oplossen alvorens verder te gaan. Er wordt gestart met de minst precieze interpretatie W$\textsubscript{0}$ om uiteindelijk stapsgewijs tot een exacte interpretatie W$\textsubscript{n}$ met maximale precisie te komen waarvoor geldt dat W$\textsubscript{n}$ $\cup$ G $\models$ T. Hoe deze stappen verlopen staat beschreven in onderstaand algoritme. Hier wordt W opnieuw opgedeeld in drie verzamelingen U, P en O. U is de verzameling van predicaten met een waarheidswaarde $\geq\textsc{p}$ u, waarvoor geldt dat deze toegekend zijn door de gebruiker. De tweede verzameling P bevat eveneens predicaten met een waarheidswaarde $\geq\textsubscript{p}$ u, maar deze zet zijn de propagaties die volgen uit U. O tenslotte is de set van predicaten waarvoor de waarheidswaarde nog onbekend is. Voor W$\textsubscript{0}$ geldt: W$\textsubscript{0}$ = O$\textsubscript{0}$ en U$\textsubscript{0}$ = P$\textsubscript{0}$ = $\emptyset$. In het verder verloop van de tekst zal deze beschrijven blijven gelden en terugkomen.

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function Selectieproces} (U$\textsubscript{i}$)\;
	\Input{De nieuwe keuze van de gebruiker P$\textsubscript{i}$}
	\Output{}
	\eIf{Sat(U$\textsubscript{i}$)}
		{
		V $\leftarrow$ P$\textsubscript{i-1}$ $\cap$ O$\textsubscript{i}$\;
		\eIf{V $\neq$ $\emptyset$}
			{
			V' $\leftarrow$ KeuzeGebruiker(V)\; 
			Selectieproces(U$\textsubscript{i}$ $\cup$ V')\;
			}
			{
			P$\textsubscript{i}$ $\leftarrow$ Propagate(U$\textsubscript{i}$)\;	
			NieuweGebruikerActie(U$\textsubscript{i-1}$,U$\textsubscript{i}$,
			P$\textsubscript{i-1}$,P$\textsubscript{i}$,
			O$\textsubscript{i-1}$,O$\textsubscript{i}$)\;
			}
		}
		{
		N $\leftarrow$ Unsat(U$\textsubscript{i}$)\; 
		K,L $\leftarrow$ ManueleResolutie(N)\;
		U'$\textsubscript{i}$ $\leftarrow$ U$\textsubscript{i}$ 
		[K] - L\; 
		Selectieproces(U'$\textsubscript{i}$)\;
		}
	\caption{Selectieproces}
\end{algorithm}

\subsection{Propagatie}
Bij het samenstellen van een ISP kan het systeem de informatie die de gebruiker reeds verder gaan propageren. Hierbij baseert het systeem zich op de regels van de theorie. Neem het volgende voorbeeld: 
\begin{lstlisting}[mathescape]
Geselecteerd(A) $\Rightarrow$ Geselecteerd(B)
\end{lstlisting}
Deze regel zegt dat als A geselecteerd is, B ook geselecteerd moet zijn. Als de gebruiker A selecteerd, zal het systeem hieruit afleiden dat B ook geselecteerd moet doen. In de GUI zal te zien zijn dat B ook geselecteerd is, hoewel de gebruiker dit niet expliciet heeft gekozen.

\subsection{Model Expansie}
Als de gebruiker al zijn/haar voorkeuren heeft ingevuld in de parti\"{e}le interpretatie W$\textsubscript{i}$ met U$\textsubscript{i}$ $\cup$ P$\textsubscript{i}$ $\cup$ O$\textsubscript{i}$ = W$\textsubscript{i}$ en O$\textsubscript{i}$ $\neq$ $\emptyset$. Dan kan het systeem de verzameling van predicaten O$\textsubscript{i}$ waarvan de waarheidswaarde nog onbekend is, verder oplossen. Om zo tot een interpretatie W$\textsubscript{f}$ to komen met U$\textsubscript{i}$ $\cup$ P$\textsubscript{i}$ $\subseteq$ W$\textsubscript{f}$. W$\textsubscript{f}$ is tevens (precisie )maximaal en W$\textsubscript{f}$ $\cup$ G $\models$ T. Anders gezegd zal het systeem de parti\"{e}le selectie verder vervolledigen tot een geldig ISP. 

\subsection{Minimizatie}
Het is niet alleen mogelijk om een parti\"{e}le selectie verder te laten vervolledigen, maar om hierbij ook een parameter in acht te nemen en een interpretatie W$\textsubscript{f}$ te bekomen waarbij deze parameter zo klein mogelijk is. Het systeem kan een optimalisatie van volgende parameters zoeken:
\begin{itemize}
\item[Werklast] Met werklast wordt bedoeld het aantal studiepunten dat opgenomen wordt. Een student is verplicht vakken te selecteren en gekoppeld aan die vakken zijn studiepunten. De student kan vragen aan het systeem om een ISP samen te stellen waarbij de werklast (de som van de studiepunten van de geselecteerde vakken) ze laag mogelijk is.
\item[Werklast per semester] Vakken die geen jaarvakken zijn, vallen ofwel in het eerste semester of het tweede. Het systeem kan een ISP samenstellen waarbij het verschil in studiepunten tussen geselecteerde vakken van eerste en tweede semester zo klein mogelijk is. Zodat de werklast zo goed mogelijk verdeeld is tussen beide semesters.
\item[Overlap] Vakken hebben uiteraard lesmomenten en het kan al eens gebeuren dat deze lesmomenten voor verschillende vakken samenvallen. Dit is uiteraard niet ideaal voor de student om die niet op twee plaatsen tegelijk kan zijn. Stel dat er het lesmoment van vak A gepland is van 16u tot 18u en het lesmoment voor vak B vindt plaats op dezelfde dag van 15u tot 17u. De overlap bedraagt dan 60 minuten. De student kan een ISP laten genereren waarbij de totale som van alle overlap zo minimaal mogelijk is. 
\end{itemize}

\subsection{Ongedaan Maken}
Het ongedaan kunnen maken van selecties is een van de aspecten waar meerdere strategi\"{e}en mogelijk zijn. Elke stap in het selectieproces (nieuwe selectie door de gebruiker) wordt bijgehouden in een zogenaamde \emph{actie}. Deze actie bevat niet alleen die nieuwe interpretatie W$\textsubscript{i}$ maar ook de voorgaande W$\textsubscript{i-1}$ zodanig dat als en actie ongedaan gemaakt wordt het systeem weet wat de toestand voorheen was en hier naar kan terugkeren. Het is niet noodzakelijk zo dat in een actie A$\textsubscript{i}$ met interpretaties W$\textsubscript{i-1}$ en W$\textsubscript{i}$ dat W$\textsubscript{i-1}$ $\leq\textsubscript{p}$ W$\textsubscript{i}$. Acties beschrijven elke handeling in de tijd gemaakt door de gebruiker, dus ook de waarheidswaarde van een predicaat minder specifiek maken. Ongedaan maken in deze context betekent dus niet automatisch de huidige selectie minder specifiek maken, maar eerder terugkeren in de tijd.

\paragraph{Strategie 1a}
De eerste strategie houdt in dat als een actie ongedaan gemaakt wordt de interpretatie W$\textsubscript{i}$ simpelweg vervangen wordt door de voorgaande W$\textsubscript{i-1}$. Dit is wellicht de meest simpele strategie aangezien er geen extra bewerkingen uitgevoerd moeten worden buiten het terugkeren naar de voorgaande interpretatie.

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function MaakActieOngedaan} (Ac)\;
	\Input{De actie die ongedaan gemaakt moet worden A$\textsubscript{i}$}
	\Output{}
	verwijder(A$\textsubscript{i}$)\;
	W$\textsubscript{i}$ $\leftarrow$ W$\textsubscript{i-1}$\;
	\caption{MaakActieOngedaan\label{alg:Strategie1a}}
\end{algorithm}

\paragraph{Strategie 1b}
Bij de voorgaande strategie staat een actie ongedaan maken gelijk aan simpelweg de klok terugdraaien en W$\textsubscript{i}$ vervangen door W$\textsubscript{i-1}$. Dus eventuele propagaties die volgden uit de keuze van de gebruiker in de actie worden ook ongedaan gemaakt. En in plaats van alles simpelweg ongedaan te maken zou het beter zijn als de gebruiker de keuze krijgt om eventuele propagaties te behouden. Dit zorgt echter voor het volgende probleem. De assumptie is dat acties handelingen weergeven in de tijd gemaakt door de gebruiker, het ongedaan maken van handelingen wordt dus gezien als het terugdraaien van de tijd. Maar als de gebruiker kiest om een actie ongedaan te maken en tegelijk eventuele propagaties toch wil behouden dan geldt deze assumptie niet meer. In \ref{alg:MaakActieOngedaan} staat beschreven hoe dit probleem opgelost kan worden. 
Het is simpelweg een uitbreiding op de eerste strategie, een actie wordt nog altijd verwijderd en de laatste interpretatie W$\textsubscript{i}$ wordt vervangen door de voorgaande W$\textsubscript{i-1}$. Maar waar het hier voorheen stopte gebeurt er nu het volgend. Er wordt gecontroleerd of er een set van predicaten V bestaat die zowel toebehoren aan O$\textsubscript{i-1}$ en P$\textsubscript{i}$. Ofwel predicaten waarvoor de waarheidswaarde eerst onbekend was en daarna een meer specifieke waarheidswaarde hebben gekregen d.m.v. propagatie als gevolg van de keuze van de gebruiker. Is deze set niet leeg dan zal de gebruiker moeten kiezen in \emph{KeuzeGebruiker} welke van de propagaties te houden. In het geval dat de gebruik kiest om propagaties te behouden, worden deze niet langer gezien als propagaties maar eerder als keuzes gemaakt door de gebruiker. Deze worden toegevoegd een de verzameling U en dit wordt gezien als een nieuwe handeling in het selectieproces waarvoor een nieuwe actie gecre\"{e}erd zal worden.

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function MaakActieOngedaan} (Ac)\;
	\Input{De actie die ongedaan gemaakt moet worden A$\textsubscript{i}$}
	\Output{}
	V $\leftarrow$ O$\textsubscript{i-1}$ $\cap$ P$\textsubscript{i}$\;
	verwijder(A$\textsubscript{i}$)\;
	W$\textsubscript{i}$ $\leftarrow$ W$\textsubscript{i-1}$\;
	\If{V $\neq$ $\emptyset$}
		{
		V' $\leftarrow$ KeuzeGebruiker(V)\;
		\If{V' $\neq$ $\emptyset$} 
			{
			Selectieproces(U$\textsubscript{i-1}$ $\cup$ V')\;
			}
		}
	\caption{MaakActieOngedaan\label{alg:Strategie1b}}
\end{algorithm}

\paragraph{Strategie 2}
Voorheen was de assumptie dat een actie ongedaan maken gelijk stond aan de tijd als het ware terugdraaien en de interpretatie vervangen door de voorgaande. En dat dit niets te maken had met de precisie ordening van de interpretaties. Voor deze strategie wordt er niet meer uitgegaan van deze assumptie, maar in plaats daarvan staat ongedaan maken gelijk aan eender welke keuze van de gebruiker die ervoor zorgt dat de interpretatie minder precies wordt. Dit kan zijn de waarheidswaarde van een predicaat ongedaan (minder precies) maken of een waarheidswaarde van een predicaat veranderen van bv. waar naar onwaar. Met als gevolg dat de interpretatie minder precies is omdat propagaties niet meer gelden. Wat verandert is dat in deze situatie geen expliciete acties meer worden bijgehouden zoals voorheen, en dat ongedaan maken nu een onderdeel is van het selectieproces zelf. Kort gezegd verandert enkel de assumptie over ongedaan maken. De rest van de werking blijft dezelfde, behalve dat zoals voorheen niet meer gebruikt worden. De werking staat beschreven in \ref{alg:Strategie2}.

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function Selectieproces} (U$\textsubscript{i}$)\;
	\Input{De nieuwe keuze van de gebruiker P$\textsubscript{i}$}
	\Output{}
	\eIf{Sat(U$\textsubscript{i}$)}
		{
		V $\leftarrow$ P$\textsubscript{i-1}$ $\cap$ O$\textsubscript{i}$\;
		\eIf{V $\neq$ $\emptyset$}
			{
			V' $\leftarrow$ KeuzeGebruiker(V)\; 
			Selectieproces(U$\textsubscript{i}$ $\cup$ V')\;
			}
			{
			P$\textsubscript{i}$ $\leftarrow$ Propagate(U$\textsubscript{i}$)\;	
			\sout{NieuweGebruikerActie(U$\textsubscript{i-1}$,U$\textsubscript{i}				$,P$\textsubscript{i-1}$,P$\textsubscript{i}$,
			O$\textsubscript{i-1}$,O$\textsubscript{i}$)}\;
			}
		}
		{
		N $\leftarrow$ Unsat(U$\textsubscript{i}$)\; 
		K,L $\leftarrow$ ManueleResolutie(N)\;
		U'$\textsubscript{i}$ $\leftarrow$ U$\textsubscript{i}$ 
		[K] - L\; 
		Selectieproces(U'$\textsubscript{i}$)\;
		}
	\caption{Selectieproces\label{alg:Strategie2}}
\end{algorithm}

\section{Conflict Explanation}
Het is mogelijk dat de gebruiker een verkeerde keuze maakt waardoor de theorie niet meer satisfieerbaar is. Simpel gezegd heeft de gebruiker een waarde gekozen voor een bepaalde variabele, zodanig dat dit ervoor zorgt dat \'{e}\'{e}n of meerdere regels uit de theorie samen niet meer waar kunnen worden gemaakt.

\begin{lstlisting}[mathescape]
Geselecteerd(A) $\wedge$ Geselecteerd(B)
\end{lstlisting}

Het bovenstaande voorbeeld van een theorie bevat \"{e}\"{e}n regel die zegt dat A en B beide geselecteerd moeten zijn. Stel dat de gebruiker nu kiest $\neg$ Geselecteerd(A). Hieruit volgt dat de regel uit de theorie nooit waar kan zijn, of niet satisfieerbaar wordt. Dit is een conflixt en het is aan het systeem om een de gebruiker duidelijk te maken dat er een probleem is, wat het probleem inhoudt en hoe de gebruiker dit kan oplossing. Dit laatste behoort tot het domein van conflict explanation. IDP gebruikt momenteel twee technieken om oorzaken van niet satisfieerbaarheid op te sporen. De unsatstructure spoort een set van variabelen op die het probleem veroorzaken. Vervolgens is er de unsattheory, die zoekt naar een minimale set van regels uit de theorie die niet waar gemaakt kunnen worden gegeven de huidige selectie.

\subsubsection{Unsatstructure}
De unsatstructure is een effici\"{e}nte tool om aan de gebruiker te kunnen meedelen, welke van de voormalige selecties problemen veroorzaken. In het voorbeeld van het ISP werd er een opsplitsing gemaakt tussen twee sets van predicaten, $\Gamma$ waarvoor de invulling G vooraf bekend is en $\Omega$ waarvoor een interpretatie W samengesteld dient te worden door de student. W bestond zelf opnieuw uit drie verzamelingen U, P en O. Als een interpretatie ervoor zorgt dat de theorie niet meer satisfieerbaar wordt, dan is dit te wijten aan de keuze van de gebruiker U. En het is van deze verzameling dat de unsatstructure een precisie minimale deelverzameling V zal zoeken als oorzaak van het probleem. De student krijgt een oplijsting te zien van V, en zal de mogelijkheid krijgen om hier veranderingen in aan te brengen zodoende het probleem op te lossen.

\subsubsection{Reified Constraints}
Wat opvalt is dat de voorgaande techniek enkel een verzameling selecties teruggeeft die bijdragen tot het probleem. Maar verdere uitleg over welke regel(s) uit de theorie niet meer waar gemaakt kunnen worden en waarom wordt niet gegeven. Dus de gebruiker krijgt enkel de foute selectie te zien, zonder erbij te zeggen wat er juist mis mee is. Herinner de unsattheory zoekt achter en minimale set van regels uit de theorie die niet meer waar gemaakt kunnen worden. Dit is het exact hetgene wat de gebruiker hoort te weten om het probleem op te lossen, maar het probleem zit het hem in de formulering. De unsattheory formuleert de fouten in de IDP syntax FO(\textperiodcentered). Deze syntax is voor de doorsnee informaticus met een achtergrond in eerste orde logica of IDP goed te lezen, maar voor een student die geen ervaring heeft met deze domeinen zal ongetwijfeld niet in staat zijn deze regels te ontcijferen. Neem als voorbeeld onderstaande regel, elke student computerwetenschappen zal vrij snel kunnen achterhalen wat de regel inhoud. Maar personen zonder deze achtergrond zullen dit niet kunnen verstaan.
\begin{lstlisting}[mathescape, caption=IDP Rule Example, frame=topline/bottomline]
$\forall$vg[VakGroep] : IsType(vg,AVO) $\Rightarrow$ GesAantalStupunVakGr(vg) 
= sum{v[Vak], sp[Studiepunten],f[Fase] : InVakGroep(v,vg) 
$\wedge$ Geselecteerd(v,f) $\wedge$ AantalStudiepunten(v)=sp : sp }.
\end{lstlisting}
Een mogelijke oplossing voor dit probleem komt in de vorm van reified constraints. De theorie T bestaat uit regels (constraints) en hierin wordt onderscheid gemaakt tussen 2 sets van regels. De eerste is de set van regels B die altijd waar zullen zijn, deze noemen we achtergrond constraints. De andere set is die van regels F genaamd voorgrond constraints die de gebruiker moet zien waar te maken d.m.v. een correcte interpretatie samen te stellen. Het is deze set van regels F, waarvoor reified constraints gebruikt zullen worden. Voor zij die niet bekend zijn met het concept van reified constraints, het is een zeer simpele techniek. Een regel C (constraint) kan heel simpel omgevormd worden tot een reified constraint door C equivalent te maken aan een booleaanse waarde B. Dus een regel C ziet er als dan als volgt uit, B $\leftrightarrow$ C. De waarheidswaarde van C is dan equivalent aan die van B, dus als de regel niet consistent of 'false' is, zal B dus ook 'false' zijn, hetzelfde geldt ook voor 'true' uiteraard. De voorgaande regel ziet er dan als volgt uit. 
\begin{lstlisting}[mathescape, caption=IDP Reified Constraint Example, frame=topline/bottomline]
Rule $\leftrightarrow$ $\forall$vg[VakGroep] : IsType(vg,AVO) $\Rightarrow$ GesAantalStupunVakGr(vg) 
= sum{v[Vak], sp[Studiepunten],f[Fase] : InVakGroep(v,vg) 
$\wedge$ Geselecteerd(v,f) $\wedge$ AantalStudiepunten(v)=sp : sp }.
\end{lstlisting}
Rule is de booleaanse variabele wiens waarheidswaarde die van de regel reflecteert. Op deze manier hoeven we enkel na te gaan of Rule true of false is om te weten te komen of de regel (in)consistent is gegeven de selectie van de gebruiker. Dit alleen biedt natuurlijk niet veel extra informatie, maar het nut van de booleaanse variabele is wel degelijk belangrijk. Voor elke regel uit F is er op voorhand een beschrijving opgesteld in natuurlijke taal met de redenering achter het eventuele falen van die regel. Aan de hand van de reified constraints kan er heel gemakkelijk achterhaald worden welke regels er wel of niet consistent zijn door simpelweg te kijken naar de booleaanse waarde in de regels. Is de booleaanse variabele false, dan moet de gebruiker de bijhorende beschrijving te zien krijgen voor deze regel. Hoewel dit een zeer gemakkelijke en generische manier is om aan conflict explanation te doen, zijn de mogelijkheden van deze techniek toch gelimiteerd en niet altijd voldoende toereikend. Ten eerste is de uitleg vaak oppervlakkig en niet specifiek genoeg om duidelijk te kunnen verklaren waarom een regel inconsistent is. 
\begin{lstlisting}[mathescape, caption=Reified constraint Shortcomings]
$\forall$vg[VakGroep] : MaxAantalStudiepunten(vg) > 0 $\Rightarrow$ 
MinAantalStudiepunten(vg) $\leq$ GeselecteerdAantalStudiepuntenPerVakGroep(vg) $\leq$ MaxAantalStudiepunten(vg).
\end{lstlisting}
Bovenstaande regel stelt dat voor elke vakgroep, het totaal aantal geselecteerde studiepunten van deze vakgroep tussen diens minimum en maximum moet liggen, als het maximum aantal studiepunten ervan groter is dan nul. In het geval dat deze regel inconsistent is krijgt de student de volgende uitleg te zien. \emph{Je hebt niet voor alle vakgroepen tussen het minimum en maximum aantal studiepunten geselecteerd.} De verklaring is algemeen en geeft geen specifieke details. Zo zegt het niet voor welke vakgroep het geselecteerd aantal studiepunten niet klopt, en of het er nu teveel of te weinig zijn. Dus de verklaringen zijn redelijk beperkt in hun mogelijkheden.

En ten tweede laat deze methode enkel toe om inconsistente regels op te sporen.
Een Interactief Configuratieprobleem zoals het ISP bevat een verzameling predicaten $\Omega$ waarvoor de gebruiker (in dit geval een student) stapsgewijs een interpretatie W samenstelt. Deze interpretatie moet uiteindelijk als ze compleet is, een geldig model zijn volgens de regels van de theorie. Een regel is inconsistent als ze niet voldaan is gegeven de huidige parti\"{e} selectie. Dit wil niet zeggen dat de regel niet meer consistent kan worden naarmate de interpretatie verder ingevuld wordt door de student. Terwijl een set van regels die nooit samen waar gemaakt kunnen worden gegeven de huidige parti\"{e}le selectie niet-satisfieerbaar zijn. Het is deze laatste set van regels die dient gevonden te worden. De techniek van reified constraints op zich kan dit niet verwezenlijken. Maar door deze techniek te combineren met de unsatstructure wordt dit wel een mogelijkheid. 


