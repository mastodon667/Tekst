\chapter{Implementatie}
\label{cha:implementatie}

\subsection{Inleiding}
De kennis over het ISP staat beschreven in een theorie T over een vocabularium $\Sigma$. Dit vocabularium bestaat uit een set $\Sigma_{p}$ van predicaatsymbolen en een set van functiesymbolen $\Sigma_{f}$. Een interpretatie I bestaat uit D, de verzameling domeinelementen, een mapping van elk functiesymbool f/n naar een functie met ariteit n op D en een mapping van elk predicaatsymbool P/n naar een relatie R $\subseteq$ D$_{n}$. Een three-valued parti\"{e}le interpretatie bestaat uit een mapping op drie waarheidswaarden {u,t,f} respectievelijk onbekend, waar en niet waar. De waarheidswaarden zijn partieel geordend volgens precisie, u $\leq_{p}$ f en u $\leq_{p}$ t. Het is dus de bedoeling dat er een interpretatie I wordt samengesteld die elk domeinelement afbeeldt op een waarheidswaarde zodanig dat I $\models$ T, of anders gezegd dat I een model is van de theorie T. De predicaten in $\Sigma_{p}$ bestaat uit twee verzamelingen. De eerste verzameling $\Gamma$ bevat de predicaten waarvoor er reeds een interpretatie G $\subseteq$ I bekend is, deze zijn dus vooraf gegeven door het systeem. De andere verzameling $\Omega$ zijn de predicaten waarvoor de interpretatie W $\subseteq$ I nog niet gegeven is en die door de gebruiker (in dit geval de student) ingevuld zal moeten worden. W en G vormen samen de interpretatie I, het is dus de bedoeling om een invulling te zoeken voor W zodanig dat I consistent is met alle regels van de theorie T.

\section{Constructie ISP Theorie}

\paragraph{Analyse van het ISP}
Alvorens te beginnen aan het opstellen van een theorie in IDP, is het belangrijk om de regels en structuren van het ISP te bestuderen. Het doel is om een theorie te ontwikkelen die zo algemeen mogelijk is, zodanig dat ze in staat is om een correcte interpretatie te beschrijven voor verschillende opleidingen. En het vinden van structuren, patronen, regels en types die vaak (of altijd) terugkomen, kan in grote mate bijdragen aan zo'n goede theorie. Omdat het onderwijsaanbod aan de K.U. Leuven zodanig groot is, heb ik mijn analyse beperkt tot een kleine groep opleidingen binnen de faculteit Wetenschappen en Ingenieurswetenschappen. Wat meteen opvalt is dat bepaalde types van elementen telkens voorkomen namelijk vakken (meer specifiek de vak code), studiepunten, fases en semesters. Vakken maken altijd deel uit van een \textit{vakgroep}, deze zijn opgedeeld in twee delen, het plichtgedeelte en het keuzegedeelte. Elk vak dat deel uitmaakt van een vakgroep behoort tot \'{e}\'{e}n van deze verzamelingen. Vakgroepen gaan gepaard met specifieke regels, deze hebben vooral te maken met de hoeveelheid studiepunten een student verplicht is te op te nemen uit deze groep (studiepunten opnemen doe je door een vak te selecteren). Naast regels die betrekking hebben tot enkel vakgroepen, bestaan er ook regels die zich niet enkel beperken tot \'{e}\'{e}n specifieke vakgroep maar eerder een bepaald type vakgroep. Zo bevat de opleiding master toegepaste informatica drie vakgroepen met elk de vakken van \'{e}\'{e}n van de specialisaties (nl. multimedia, artifici\"{e}le intelligentie en software ontwikkeling en gedistribueerde systemen). Deze vakgroepen maken allemaal deel uit van hetzelfde type, namelijk het type \textit{specialisatie}. Voor dit type gelden bepaalde regels, bovenop die van de individuele vakgroepen zelf. Deze types komen vaak terug in meerdere opleidingen evenals de regels die ermee verbonden zijn. 
Zo is elke opleiding op zich een vakgroep van het type \textit{opleiding}. 

Zo bestaan er ook nog ander types van vakgroepen, in het zojuist gebruikte voorbeeld kwam al het type specialisatie aan bod. Verscheidene opleidingen geven de keuze tussen meerdere specialisaties. Verwacht wordt dat je van minstens \'{e}\'{e}n zo'n specialisatie alle verplichte vakken opneemt. Naast specialisatie bestaat er ook het type \textit{verdere specialisatie}, waarin de student verplicht wordt een bepaald aantal studiepunten op te nemen aan vakken uit deze of bepaalde andere vakgroepen. Vervolgens is er het type \textit{algemeen vormende en onderzoeksondersteunend}. En als laatste is er het type \textit{bachelor verbredend pakket}, waarin studenten die beginnen aan hun masteropleiding vakken moeten opnemen die ontbraken in hun bacheloropleiding. Dit zijn de types die voorkomen in minstens \'{e}\'{e}n van de opleidingen uit het huidige domein van opleidingen. Het is mogelijk dat sommige types van vakgroepen niet telkens voorkomen, en dus de regels ook niet van kracht zijn. In een bacheloropleiding zal bijvoorbeeld nooit een vakgroep voorkomen van het type bachelor verbredend pakket. De resultaten van de analyse moeten vervolgens verwerkt worden in een vocabularium dat gebruik maakt van deze types en structuren. Op basis van dat vocabularium hoort dan een theorie ontwikkeld te worden die in staat is een geldige interpretatie voor de verschillende opleidingen te beschrijven. 

\subsection{Vocabularium}
Het vocabularium bestaat uit drie verzamelingen namelijk de types, predicaten en functies. Hieronder staan ze allemaal kort beschreven.
\subsubsection{Types}
\begin{description}
\item [Vak] Dit type omvat de verzameling van de verschillende vakken in het domein, elke opleiding bestaat uit verschillende vakken die een gebruiker mogelijk kan selecteren. Meer specifiek zijn dit de unieke vak codes van een vak. De naam van een vak is namelijk niet altijd uniek in tegenstelling tot de vak code. De domeinwaarden zijn dus niet de naam in natuurlijke taal, maar de unieke vak code.
\item [VakGroep] Vakken maken altijd deel uit van een groep, en per vakgroep gelden vaak unieke regels. 
\item [VakGroepType] Elke vakgroep maakt deel uit van een bepaald type groep, en per type groep gelden er bepaalde regels bovenop de regels van de individuele groep zelf.
\item [Fase] Opleidingen bestaan uit fases oftewel jaren, de master computerwetenschappen bestaat bijvoorbeeld uit 2 fases. Vakken binnen een opleiding kunnen enkel gevolgd worden tijdens de fase van de opleiding waartoe ze behoren. 
\item [Semester] De K.U. Leuven werkt met een semester systeem, dit wil zeggen dat elke fase (schooljaar) is opgedeeld in twee semesters. Elk vak kan gevolgd worden in het semester waartoe het behoort. Er bestaan ook jaarvakken waarvoor de werklast verdeeld is tussen beide semesters, een voorbeeld hiervan is de masterproef.
\item [Studiepunten] Ieder vak bevat studiepunten, deze beschrijven de geschatte werklast voor dit vak. Vakgroepen vereisen vaak dat je een bepaalde hoeveelheid een studiepunten opneemt. 
\end{description}

\subsubsection{Predicaten}
De predicaten zijn opgedeeld in twee verzamelingen, de eerste verzameling $\Gamma$ omvat alle predicaten die op voorhand gegeven zijn en waarvan de waarheidswaarde al bekend is. In feite zijn dit de predicaten die de eigenlijke samenstelling van een opleiding uitdrukken. Dit is een lijst van de predicaten die tot deze groep behoren:
\begin{description}
\item [IsType(VakGroep,VakGroepType)] vakgroepen behoren altijd tot \'{e}\'{e}n bepaald type. Bovenop de regels die van toepassing zijn op de individuele vakgroepen, zijn er ook nog regels van toepassing volgens de verschillende types.
\item [InVakGroep(Vak,VakGroep)] Vakken maken altijd deel uit van een bepaalde vakgroep, InVakGroep/2 drukt deze relatie uit. 
\item [InFase(Vak,Fase)] Dit predicaat drukt uit in welke fases van de opleiding een vak gevolgd kan worden, voor elk vak bestaat er minstens \'{e}\'{e}n fase waarin het gegeven wordt. Als de student en vak wil volgen heeft hij/zij de keuze uit \'{e}\'{e}n van deze fases.
\item [Verplicht(Vak,VakGroep)] Elke vakgroep is opgesplitst in twee delen, het keuzegedeelte en het plichtgedeelte. Vakken die verplicht zijn zullen mogelijk opgenomen moeten worden door de student.
\end{description}

De tweede verzameling $\Omega$ zijn de predicaten waarvan de waarheidswaarde op voorhand niet gekend is, en waarvan verwacht wordt dat de gebruiker deze stap per stap invult. Hiertoe behoren slechts twee predicaten namelijk Geselecteerd(Vak,Fase) en GeenInteresse(Vak). Geselecteerd/2 geeft aan welke vakken de student wenst op te nemen tijdens de opleiding. GeenInteresse/1 daarentegen is eigenlijk een predicaat waarmee aangegeven kan worden dat een student helemaal geen interesse heeft om een vak te volgen. Dit is vooral handig als de student een geldige selectie wil laten genereren door het systeem waarbij hij/zij op voorhand kan aangeven dat deze selectie zeker niet de vakken kiest waarin de student geen interesse heeft. Het is niet verplicht dat de gebruiker invulling geeft aan dit predicaat. Door aan te geven dat de student geen interesse heeft om een bepaald vak te volgen kan het systeem afleiden dat er geen fases zijn waarin het vak geselecteerd kan worden.

\subsubsection{Functies}
De functies koppelen een bepaald resultaat aan een combinatie van waarden uit het domein. Zo geven de functies MinAantalStudiepunten(VakGroep):Studiepunten en MaxAantalStudiepunten(VakGroep):Studiepunten respectievelijk het minimum en het maximum aantal studiepunten weer dat de student verplicht is te selecteren. Deze relaties zijn gekend op voorhand door het systeem en de student moet uiteraard trachten zich hieraan te houden. GeselecteerdAantalStudiepuntenPerVakGroep(VakGroep):Studiepunten is de relatie tussen het de som van de studiepunten van de vakken die reeds geselecteerd zijn die behoren tot de betreffende vakgroep. Naargelang de selectie kunnen deze waarden verschillen aangezien ze afhankelijk zijn van de keuze van de gebruiker. In het vocabularium zijn meerdere functies terug te vinden die gelijkaardige relaties uitdrukken zoals hierboven beschreven. 

\section{Lessenrooster}
Het lessenrooster wordt mee in rekening genomen, de front-end toont een weergave van het lessenrooster dat volgt uit de keuze van de student. De student heeft ook de mogelijkheid een optimaal ISP te laten genereren waarbij een bepaalde parameter geminimaliseerd wordt. E\'{e}n van deze parameters is overlap, de totale tijd van alle lesmomenten die elkaar overlappen. Om dit allemaal in rekening te kunnen brengen, is er ook een theorie ontwikkeld voor de beschrijving van het lessenrooster. Deze theorie beschrijft de opmaak van het lessenrooster voor \'{e}\'{e}n lesweek, aangezien elke lesweek in een semester vaak hetzelfde is. Deze theorie wordt gecombineerd met die van het ISP, deze combinatie laat toe om een optimaal ISP te genereren met zo weinig mogelijk overlap tussen verschillende lesmomenten.

\subsection{Vocabularium}

\subsubsection{Types}
\begin{description}
\item[Vak] Het type vak is hetzelfde type als dat uit het vocabularium van het ISP, m.a.w. de vak code. Het enige verschil is dat domeinelementen van het type Vak gezien worden als geselecteerd door de student. 
\item[Les] Dit type beschrijft een individueel lesmoment.
\item[Slot] Om de omvang van het zoekdomein te beperken wordt de tijd beschreven d.m.v. slots, zo'n slot is gelijk aan 30 minuten. Een werkdag start om 8 uur en eindigt om 21 uur, \'{e}\'{e}n dag telt vervolgens 26 slots met een totaal van 130 slots per week. Slot 1 is het eerste halfuur op maandag van 8 uur tot 8:30 uur en slot 27 is het eerste half uur van dinsdag op hetzelfde tijdstip.
\end{description}

\subsubsection{Predicaten}
\begin{description}
\item[IsSchaduwVak(Vak,Vak)] Een vak kan een schaduwvak zijn van een ander, wat wil zeggen dat de lesmomenten van het schaduwvak ook deel uitmaken van de lesmomenten van het andere vak.
\item[HeeftLes(Vak,Les)] Dit beschrijft de relaties tussen vakken en hun lesmomenten.
\item[Start(Les,Slot)] Elk lesmoment start op een bepaald tijdstip, een lesmoment dat start op maandag om 8 uur, start dus op slot 1. 
\item[Eindigt(Vak,Les)] Elk lesmoment eindigt uiteraard ook, het tijdstip dat een lesmoment eindigt stemt overeen met de eindtijd van een slot. Eindigt een lesmoment op maandag om 9 uur, dan zal het slot 2 het laatste slot zijn van dit lesmoment.
\end{description}

\subsubsection{Functies}
\begin{description}
\item[Overlap(Les,Les)] De enige functie is de functie voor het berekenen van de overlap tussen de verschillende lesmomenten die niet van hetzelfde vak zijn. De functie telt hoeveel slots de lesmomenten gemeenschappelijk hebben.
\end{description}

\section{Features}
Elke keuze die de gebruiker maakt moet zorgvuldig afgehandeld worden om te kunnen garanderen dat de selectie altijd satisfieerbaar is. De voorwaarde is dat als de gebruiker een keuze maakt die ervoor zorgt dat de theorie niet langer satisfieerbaar is, hij hier meteen op de hoogte van wordt gebracht zodanig dat hij dit kan oplossen alvorens verder te gaan. Er wordt gestart met de minst precieze interpretatie W$_{0}$ om uiteindelijk stapsgewijs tot een exacte interpretatie W$_{n}$ met maximale precisie te komen waarvoor geldt dat W$_{n}$ $\cup$ G $\models$ T. Hoe deze stappen verlopen staat beschreven in onderstaand algoritme. Hier wordt W opnieuw opgedeeld in drie verzamelingen U, P en O. U is de verzameling van predicaten met een waarheidswaarde >$_{p}$ u, waarvoor geldt dat deze toegekend zijn door de gebruiker. De tweede verzameling P bevat eveneens predicaten met een waarheidswaarde >$_{p}$ u, maar deze set zijn de propagaties die volgen uit U. O tenslotte is de set van predicaten waarvoor de waarheidswaarde nog onbekend is. Voor W$_{0}$ geldt: W$_{0}$ = O$_{0}$ en U$_{0}$ = P$_{0}$ = $\emptyset$. In het verder verloop van de tekst zal deze beschrijving blijven gelden en terugkomen.

\subsection{Selectieprocedure}
Telkens de gebruiker een nieuwe keuze maakt wordt er een vaste procedure doorlopen om te garanderen dat na afloop ervan de interpretatie satisfieerbaar is en dat er een nieuwe actie gecre\"{e}erd is. Deze procedure staat beschreven in \ref{alg:selectieprocedure}. De procedure start met te controleren of de interpretatie satisfieerbaar is voor U$_{i}$ de keuze van de gebruiker. Is dit het geval dan worden de propagaties berekend die hieruit volgen, evenals de verzameling O$_{i}$ die hieruit afgeleid kan worden. Vervolgens wordt er gecontroleerd of  propagaties uit P$_{i-1}$ niet meer gelden in de nieuwe interpretatie, als dit niet het geval is wordt er een nieuwe actie aangemaakt en loopt de procedure af. Wanneer blijkt dat er wel propagaties uit P$_{i-1}$ niet meer gelden, dan zal de student in \textit{KeuzePropagatie} kunnen kiezen welke van de propagaties hij/zij wil behouden. Merk op dat als de student kiest om deze propagaties te behouden, deze niet langer als propagaties maar eerder als keuzes worden gezien die vanaf dan behoren tot U. Dit is de werking voor wanneer de interpretatie satisfieerbaar is, maar wanneer dit niet het geval is moet de procedure ervoor zorgen dat dit terug hersteld wordt. \textit{ZoekMinimaleCorrecties} zoekt achter alle mogelijke correcties om het conflict op te lossen, hieruit kiest de student er \'{e}\'{e}n. De gekozen correctie wordt ongedaan gemaakt in U$_{i}$ waarna de selectieprocedure opnieuw begint.

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function Selectieprocedure} (U$_{i}$)\;
	\Input{De nieuwe keuze van de gebruiker U$_{i}$}
	\eIf{Sat(U$_{i}$)}
		{
		P$_{i}$, O$_{i}$ $\leftarrow$ Propagatie(U$_{i}$)\;
		V $\leftarrow$ P$_{i-1}$ $\cap$ O$_{i}$\;
		\eIf{V $\neq$ $\emptyset$}
			{
			\tcp{Gebruiker kiest welke van de voorgaande propagaties te behouden}
			V' $\leftarrow$ KeuzePropagatie(V)\; 
			Selectieproces(U$_{i}$ $\cup$ V')\;
			}
			{
			P$_{i}$, O$_{i}$ $\leftarrow$ Propagatie(U$_{i}$)\;	
			NieuweGebruikerActie(U$_{i-1}$,U$_{i}$,
			P$_{i-1}$,P$_{i}$,
			O$_{i-1}$,O$_{i}$)\;
			}
		}
		{
		\tcp{Gebruiker kiest \'{e}\'{e}n mogelijk minimale oplossing}
		S $\leftarrow$ ZoekMinimaleCorrecties(U$_{i}$)\; 
		K $\leftarrow$ KeuzeCorrectie(S)\; 
		U'$_{i}$ $\leftarrow$ U$_{i}$ - K\; 
		Selectieprocedure(U'$_{i}$)\;
		}
	\caption{Selectieprocedure\label{alg:selectieprocedure}}
\end{algorithm}

\subsection{Propagatie}
Bij het samenstellen van een ISP kan het systeem de informatie die de gebruiker reeds heeft ingevoerd verder gaan propageren. Hierbij baseert het systeem zich op de regels van de theorie. Neem het volgende voorbeeld: 
\begin{lstlisting}[mathescape]
Geselecteerd(A) $\Rightarrow$ Geselecteerd(B)
\end{lstlisting}
Deze regel zegt dat als A geselecteerd is, B ook geselecteerd moet zijn. Als de gebruiker A selecteert, zal het systeem hieruit afleiden dat B ook geselecteerd moet doen. In de GUI zal te zien zijn dat B ook geselecteerd is, hoewel de gebruiker dit niet expliciet heeft gekozen.

\subsection{Model Expansie}
Als de gebruiker al zijn/haar voorkeuren heeft ingevuld in de parti\"{e}le interpretatie W$_{i}$ met U$_{i}$ $\cup$ P$_{i}$ $\cup$ O$_{i}$ = W$_{i}$ en O$_{i}$ $\neq$ $\emptyset$. Dan kan het systeem de verzameling van predicaten O$_{i}$ waarvan de waarheidswaarde nog onbekend is, verder oplossen om zo tot een interpretatie W$_{f}$ te komen met U$_{i}$ $\cup$ P$_{i}$ $\subseteq$ W$_{f}$. W$_{f}$ is tevens (precisie) maximaal en W$_{f}$ $\cup$ G $\models$ T. Anders gezegd zal het systeem de parti\"{e}le selectie verder vervolledigen tot een geldig ISP. 

\subsection{Minimizatie}
Het is niet alleen mogelijk om een parti\"{e}le selectie verder te laten vervolledigen, maar om hierbij ook een parameter in acht te nemen en een interpretatie W$_{f}$ te bekomen waarbij deze parameter zo klein mogelijk is. Het systeem kan een optimalisatie van volgende parameters zoeken:
\begin{itemize}
\item[Werklast] Met werklast wordt bedoeld het aantal studiepunten dat opgenomen wordt. Een student is verplicht vakken te selecteren en gekoppeld aan die vakken zijn studiepunten. De student kan vragen aan het systeem om een ISP samen te stellen waarbij de werklast (de som van de studiepunten van de geselecteerde vakken) ze laag mogelijk is.
\item[Werklast per semester] Vakken die geen jaarvakken zijn, vallen ofwel in het eerste of het tweede semester. Het systeem kan een ISP samenstellen waarbij het verschil in studiepunten tussen de geselecteerde vakken van eerste en tweede semester zo klein mogelijk is. Zodat de werklast zo goed mogelijk verdeeld is tussen beide semesters.
\item[Overlap] Vakken hebben uiteraard lesmomenten en het kan al eens gebeuren dat deze lesmomenten voor verschillende vakken samenvallen. Dit is uiteraard niet ideaal voor de student om die niet op twee plaatsen tegelijk kan zijn. Stel dat er het lesmoment van vak A gepland is van 16u tot 18u en het lesmoment voor vak B vindt plaats op dezelfde dag van 15u tot 17u. De overlap bedraagt dan 60 minuten. De student kan een ISP laten genereren waarbij de totale som van alle overlap zo minimaal mogelijk is. 
\end{itemize}

\subsection{Bevestigen van selectie}
Als de student denkt klaar te zijn met zijn/haar selectie, moet het systeem kunnen controleren of de interpretatie W$_{i}$ $\cup$ G $\models$ T. Het systeem gaat dus na of aan alle regels voldaan is, is dit het geval dan is W$_{i}$ $\cup$ G een model van T. Merk op: dit is niet hetzelfde als controleren of een interpretatie satisfieerbaar is. 

\subsection{Ongedaan Maken}
Het ongedaan kunnen maken van selecties is een van de aspecten waar meerdere strategie\"{e}n mogelijk zijn. Elke stap in het selectieproces (nieuwe selectie door de gebruiker) wordt bijgehouden in een zogenaamde \textit{actie}. Deze actie bevat niet alleen die nieuwe interpretatie W$_{i}$ maar ook de voorgaande W$_{i-1}$ zodanig dat als en actie ongedaan gemaakt wordt het systeem weet wat de toestand voorheen was en hier naar kan terugkeren. Het is niet noodzakelijk zo dat in een actie A$_{i}$ met interpretaties W$_{i-1}$ en W$_{i}$ dat W$_{i-1}$ $\leq_{p}$ W$_{i}$. Acties beschrijven elke handeling in de tijd gemaakt door de gebruiker, dus ook de waarheidswaarde van een predicaat minder specifiek maken. Ongedaan maken in deze context betekent dus niet automatisch de huidige selectie minder specifiek maken, maar eerder terugkeren in de tijd.

\paragraph{Strategie 1a}
De eerste strategie houdt in dat als een actie ongedaan gemaakt wordt de interpretatie W$_{i}$ simpelweg vervangen wordt door de voorgaande W$_{i-1}$. Dit is wellicht de meest simpele strategie aangezien er geen extra bewerkingen uitgevoerd moeten worden buiten het terugkeren naar de voorgaande interpretatie.

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function MaakActieOngedaan} (A$_{i}$)\;
	\Input{De actie die ongedaan gemaakt moet worden A$_{i}$}
	{W$_{i}$,W$_{i-1}$} $\in$ A$_{i}$\;
	W$_{i}$ $\leftarrow$ W$_{i-1}$\;	
	verwijder(A$_{i}$)\;
	\caption{MaakActieOngedaan\label{alg:Strategie1a}}
\end{algorithm}

\paragraph{Strategie 1b}
Bij de voorgaande strategie staat een actie ongedaan maken gelijk aan simpelweg de klok terugdraaien en W$_{i}$ vervangen door W$_{i-1}$. Dus eventuele propagaties die volgden uit de keuze van de gebruiker in de actie worden ook ongedaan gemaakt. En in plaats van alles simpelweg ongedaan te maken zou het beter zijn als de gebruiker de keuze krijgt om eventuele propagaties te behouden. Dit zorgt echter voor het volgende probleem. Een actie beschrijft de overgang van toestand W$_{i-1}$ naar W$_{i}$ als gevolg van een handeling die de gebruiker heeft gemaakt. Als een actie ongedaan gemaakt wordt, draait de tijd als het ware terug en keert het systeem terug naar de voorgaande toestand W$_{i-1}$. Als de gebruiker kiest om een actie ongedaan te maken en tegelijk eventuele propagaties toch wil behouden dan geldt deze assumptie niet meer. In \ref{alg:Strategie1b} staat beschreven hoe dit probleem opgelost kan worden. Het is simpelweg een uitbreiding op de eerste strategie, een actie wordt nog altijd verwijderd en de laatste interpretatie W$_{i}$ wordt vervangen door de voorgaande W$_{i-1}$. Maar waar het proces voorheen stopte gebeurt er nu nog een handeling. Er wordt gecontroleerd of er een set van predicaten V bestaat die zowel toebehoren aan O$_{i-1}$ en P$_{i}$. Ofwel predicaten waarvoor de waarheidswaarde eerst onbekend was en die daarna een meer specifieke waarheidswaarde hebben gekregen d.m.v. propagatie als gevolg van de keuze van de gebruiker. Is deze set niet leeg dan zal de gebruiker moeten kiezen in \textit{KeuzePropagatie} welke van de propagaties te houden. In het geval dat de gebruik kiest om propagaties te behouden, worden deze niet langer gezien als propagaties maar eerder als keuzes gemaakt door de gebruiker. Deze worden toegevoegd een de verzameling U en dit wordt gezien als een nieuwe handeling in het selectieproces waarvoor een nieuwe actie gecre\"{e}erd zal worden.

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function MaakActieOngedaan} (A$_{i}$)\;
	\Input{De actie die ongedaan gemaakt moet worden A$_{i}$}
	V $\leftarrow$ O$_{i-1}$ $\cap$ P$_{i}$\;
	{W$_{i}$,W$_{i-1}$} $\in$ A$_{i}$\;
	W$_{i}$ $\leftarrow$ W$_{i-1}$\;	
	verwijder(A$_{i}$)\;
	\If{V $\neq$ $\emptyset$}
		{
		V' $\leftarrow$ KeuzePropagatie(V)\;
		\If{V' $\neq$ $\emptyset$} 
			{
			Selectieproces(U$_{i-1}$ $\cup$ V')\;
			}
		}
	\caption{MaakActieOngedaan\label{alg:Strategie1b}}
\end{algorithm}

\paragraph{Strategie 2}
Voorheen was de assumptie dat een actie ongedaan maken gelijk stond aan de tijd als het ware terugdraaien en de interpretatie vervangen door de voorgaande. Dit heeft niets te maken met de precisie ordening van de interpretaties. In deze strategie wordt er niet meer uitgegaan van deze assumptie, maar in plaats daarvan staat ongedaan maken gelijk aan eender welke keuze van de gebruiker die ervoor zorgt dat de interpretatie minder precies wordt. Dit kan zijn de waarheidswaarde van een predicaat ongedaan (minder precies) maken of een waarheidswaarde van een predicaat veranderen van bijvoorbeeld waar naar onwaar, met als gevolg dat de nieuwe interpretatie minder precies is omdat propagaties niet meer gelden. Wat verandert is dat in deze situatie geen expliciete acties meer worden bijgehouden zoals voorheen, en dat ongedaan maken nu een onderdeel is van het selectieproces zelf. Kort gezegd verandert enkel de assumptie over ongedaan maken. De rest van de werking blijft dezelfde, behalve dat de acties van voorheen niet meer gebruikt worden. Dit heeft als gevolg dat \ref{alg:Strategie1a} of \ref{alg:Strategie1b} niet meer van toepassing zijn. De werking staat beschreven in \ref{alg:Strategie2}. 

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function Selectieproces} (U$_{i}$)\;
	\Input{De nieuwe keuze van de gebruiker U$_{i}$}
	\Output{}
	\eIf{Sat(U$_{i}$)}
		{
		P$_{i}$, O$_{i}$ $\leftarrow$ Propagatie(U$_{i}$)\;
		V $\leftarrow$ P$_{i-1}$ $\cap$ O$_{i}$\;
		\eIf{V $\neq$ $\emptyset$}
			{
			V' $\leftarrow$ KeuzePropagatie(V)\; 
			Selectieproces(U$_{i}$ $\cup$ V')\;
			}
			{
			P$_{i}$ $\leftarrow$ Propagate(U$_{i}$)\;	
			\tcp{niet langer van toepassing}
			\tcp{NieuweGebruikerActie(U$_{i-1}$,U$_{i}$,P$_{i-1}$,P$_{i}$,
			O$_{i-1}$,O$_{i}$)} 
			}
		}
		{
		S $\leftarrow$ ZoekMinimaleOplossingen(U$_{i}$)\; 
		K $\leftarrow$ KeuzeOplossing(S)\; 
		U'$_{i}$ $\leftarrow$ U$_{i}$ - K\; 
		Selectieproces(U'$_{i}$)\;
		}
	\caption{Selectieproces\label{alg:Strategie2}}
\end{algorithm}

\section{Conflict Explanation}
Het is mogelijk dat de gebruiker een verkeerde keuze maakt waardoor de interpretatie niet meer satisfieerbaar is. De gebruiker heeft een selectie U$_{i}$ samengesteld waarvoor geen precisie maximale interpretatie W$_{f}$ bestaat waarvoor geldt dat W$_{f}$ $\models$ T en U$_{i}$ $\subseteq$ W$_{f}$.
\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[mathescape]
Geselecteerd(A) $\Rightarrow$ Geselecteerd(B)
Geselecteerd(B) $\Rightarrow$ Geselecteerd(C)
\end{lstlisting}
Het bovenstaande voorbeeld van een theorie bevat een regel die zegt dat als A geselecteerd is, B ook geselecteerd moet zijn. Stel dat de gebruiker nu A selecteert en er niet aan propagatie wordt gedaan. B moet dus geselecteerd worden, maar de gebruiker kiest voor $\neq$Geselecteerd(B). Hieruit volgt dat de regel uit de theorie nooit waar kan zijn of met andere woorden niet satisfieerbaar wordt, ongeacht of de C selecteert of niet. Dit is dus een conflict en het is aan het systeem om aan de gebruiker duidelijk te maken dat er een probleem is, wat het probleem inhoudt en hoe de gebruiker dit kan oplossing. Die laatste twee taken behoren tot het domein van conflict explanation. IDP gebruikt momenteel twee technieken om oorzaken van niet satisfieerbaarheid op te sporen. De unsatstructure spoort een set van variabelen op die het probleem veroorzaken. Vervolgens is er de unsattheory, die zoekt naar een minimale set van regels uit de theorie die niet waar gemaakt kunnen worden gegeven de huidige selectie.

\subsubsection{Unsatstructure}
De unsatstructure is een effici\"{e}nte tool om aan de gebruiker te kunnen meedelen, welke van de voormalige selecties problemen veroorzaken. In het voorbeeld van het ISP werd er een opsplitsing gemaakt tussen twee sets van predicaten, $\Gamma$ waarvoor de invulling G vooraf bekend is en $\Omega$ waarvoor een interpretatie W samengesteld dient te worden door de student. W bestond zelf opnieuw uit drie verzamelingen U, P en O. Als een interpretatie ervoor zorgt dat de theorie niet meer satisfieerbaar wordt, dan is dit te wijten aan de keuze van de gebruiker U. En het is van deze verzameling dat de unsatstructure een precisie minimale deelverzameling V zal zoeken als oorzaak van het probleem. Het is in deze verzameling V dat de student zal kunnen doen om het probleem op te lossen. 

\subsubsection{Reified Constraints}
\label{sec:reifiedconstraints}
Wat opvalt is dat de unsatstructure enkel een verzameling selecties teruggeeft die bijdragen tot het probleem. Maar verdere uitleg over welke regel(s) uit de theorie niet meer waar gemaakt kunnen worden en waarom wordt niet gegeven. Dus de gebruiker krijgt enkel de foute selectie te zien, zonder erbij te zeggen wat er juist mis mee is. Herinner dat de unsattheory zoekt achter een minimale set van regels uit de theorie die niet meer waar gemaakt kunnen worden. Dit is het exact hetgeen de gebruiker kan helpen meer inzicht te krijgen in het conflict, maar het probleem zit het hem in de formulering. De unsattheory formuleert zijn output in de IDP syntax FO(\textperiodcentered). Iemand met een gepaste achtergrond zal wellicht in staat zijn dit te begrijpen, maar een student die geen ervaring heeft met deze domeinen zal het hier ongetwijfeld veel moeilijker mee hebben. Neem als voorbeeld onderstaande regel, elke student met een gepaste achtergrond zal vrij snel kunnen achterhalen wat de regel inhoud. Maar personen zonder deze achtergrond zullen dit niet kunnen verstaan.
\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[mathescape, caption=Voorbeeld constraint IDP\label{lst:constraint}, frame=single]
$\forall$vg[VakGroep] : IsType(vg,AVO) $\Rightarrow$ GesAantalStupunVakGr(vg) 
= sum{v[Vak], sp[Studiepunten],f[Fase] : InVakGroep(v,vg) 
$\wedge$ Geselecteerd(v,f) $\wedge$ AantalStudiepunten(v)=sp : sp }.
\end{lstlisting}
Een mogelijke oplossing voor dit probleem komt in de vorm van reified constraints. Voor zij die niet bekend zijn met het concept van reified constraints, het is een zeer simpele techniek. Een regel C (constraint) kan heel simpel omgevormd worden tot een reified constraint door C equivalent te maken aan een booleaanse waarde B. Dus een regel C ziet er als dan als volgt uit, B $\Leftrightarrow$ C. De waarheidswaarde van C is dan equivalent aan die van B, als de regel niet consistent of false is, zal B dus ook false zijn, hetzelfde geldt ook voor true uiteraard. 

De theorie T bestaat uit regels (constraints) en hierin wordt onderscheid gemaakt tussen 2 sets van regels. De eerste is de set van regels B die altijd waar zullen zijn, deze noemen we achtergrond constraints. De andere set is die van regels F genaamd voorgrond constraints die de gebruiker moet zien waar te maken d.m.v. een correcte interpretatie samen te stellen. Hiervoor wordt een nieuw predicaat ge\"{i}ntroduceerd in het vocabularium namelijk Regel(Nummer). Dit predicaat stelt de waarheidswaarde van een regel voor, waarbij \textit{Nummer} een nieuw type is dat staat voor het uniek nummer dat bij elke regel in F hoort. Dus elke regel  C$_{i}$ $\in$ F $\subseteq$ T is op deze manier omgevormd tot een reified constraint Regel(i) $\Leftrightarrow$ C$_{i}$. De verzameling van de nieuwe refied constraints noemen we F'. \ref{lst:reifiedconstraint} is een voorbeeld waar de regel uit \ref{lst:constraint} omgevormd is tot een reified constraint.
\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[mathescape, caption=Voorbeeld reified constraint IDP\label{lst:reifiedconstraint}, frame=single]
Regel(1) $\leftrightarrow$ $\forall$vg[VakGroep] : IsType(vg,AVO) $\Rightarrow$ 
GeselecteerdAantalStudiepuntenPerVakGroep(vg) = 
sum{v[Vak], sp[Studiepunten],f[Fase] : InVakGroep(v,vg) 
$\wedge$ Geselecteerd(v,f) $\wedge$ AantalStudiepunten(v)=sp : sp }.
\end{lstlisting}
Dit moet allemaal in een nieuwe theorie T' gestoken worden. T' is samengesteld uit B $\cup$ F'. Het vocabularium $\Sigma_{p}$' voor T' is grotendeels hetzelfde als $\Sigma_{p}$, het bestaat uit $\Omega$ $\cup$ $\Gamma$ $\cup$ $\Phi$. $\Phi$ is het nieuwe predicaat Regel(Nummer) waarvoor de interpretatie R reeds gegeven is. De waarheidswaarde van alle predicaten in R is altijd true. In \ref{alg:verklaar} staat het proces volgens reified constraints uitgelegd. Het maakt gebruik van de unsatstructure die IDP aanbiedt, deze verwacht drie parameters, een theorie, een niet-satisfieerbare interpretatie en een vocabularium. De unsatstructure gaat op zoek naar precisie minimale interpretatie I$_{m}$ $\leq_{p}$ I$\_{input}$ die nooit satisfieerbaar zal zijn volgens de theorie. De laatste parameter is optioneel maar als ze is gegeven zal I$_{m}$ hetzelfde zijn als I$_{input}$ voor alle predicaat symbolen die niet in het vocabularium zitten. Door het vocabularium $\Phi$ als parameter mee te geven zal de output hetzelfde zijn voor W$_{i}$ en G, maar voor R is het resultaat een precisie minimale interpretatie R' $\leq_{p}$ R. Herinner dat alle predicaten in R waarheidswaarde true hebben, wat wil zeggen dat voor alle reified constraints Regel(j) $\Leftrightarrow$ C$_{j}$ in F' geldt dat C$_{j}$ ook waarheidswaarde true moet hebben. Maar in het geval van een niet-satisfieerbare interpretatie zullen niet alle regels waar gemaakt kunnen worden. Het resultaat R' van de unsatstructure beschrijft deze minimale set aan regels die nooit waar gemaakt kunnen worden gegeven W$_{i}$ aan de hand van hun unieke index. In het voorbeeld \ref{lst:reco} staat een resultaat van de unsatstructure, uit vijf regels blijkt dat regel 2 nooit waar gemaakt kan worden gegeven de interpretatie.

\begin{lstlisting}[mathescape, caption=Unsatstructure voorbeeld\label{lst:reco}, frame=single]
R: Regel = {1;2;3;4;5}
R': Regel = {2}
\end{lstlisting}

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function Verklaar} (W$_{i}$)\;
	\Input{De niet-satisfieerbare interpretatie W$_{i}$}
	\Output{De set met verklaringen E}
	R' $\leftarrow$ unsatstructure(T',W$_{i}$ $\cup$ G $\cup$ R, $\Phi$)\;
	V $\leftarrow$ P$_{i-1}$ $\cap$ O$_{i}$\;
	E $\leftarrow$ list()\;
	\For{i $\in$ R'}
		{
		E.VoegToe(VindVerklaring(i))\;
		}
	\KwRet{E}
	\caption{Verklaar niet-satisfieerbaarheid\label{alg:verklaar}}
\end{algorithm}

Dit alleen biedt natuurlijk niet veel extra informatie, de gebruiker kan niets afleiden uit deze indices. Maar door op voorhand een verklaring te formuleren in natuurlijk taal en deze te koppelen aan dezelfde indices, kan het systeem een verklaring opzoeken met behulp van deze indices. Deze beschrijving hoeft slechts \'{e}\'{e}nmaal te gebeuren en de verklaring worden bewaard zodat het systeem ze kan opzoeken gedurende het selectieproces. Hoewel dit een zeer gemakkelijke en generische manier is om aan conflict explanation te doen, zijn de mogelijkheden van deze techniek toch gelimiteerd en niet altijd voldoende toereikend. De uitleg is vaak oppervlakkig en mogelijk niet specifiek genoeg om duidelijk te kunnen verklaren waarom een regel niet waar gemaakt kan worden. 

\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[mathescape, caption=Voorbeeld verklaring\label{lst:explanation}, frame=single]
$\forall$vg[VakGroep] : MaxAantalStudiepunten(vg) > 0 $\Rightarrow$ 
MinAantalStudiepunten(vg) $\leq$ GeselecteerdAantalStudiepuntenPerVakGroep(vg) 
$\leq$ MaxAantalStudiepunten(vg).
\end{lstlisting}

De regel in \ref{lst:explanation} stelt dat voor elke vakgroep, het totaal aantal geselecteerde studiepunten van deze vakgroep tussen diens minimum en maximum moet liggen, als het maximum aantal studiepunten ervan groter is dan nul. In het geval dat deze regel inconsistent is krijgt de student de bijhorende verklaring te zien: \textit{Je hebt niet voor alle vakgroepen tussen het minimum en maximum aantal studiepunten geselecteerd.}. De verklaring is algemeen en geeft geen specifieke details. Zo zegt het niet voor welke vakgroep het geselecteerd aantal studiepunten niet klopt, en of het er nu teveel of te weinig zijn. Dus de verklaringen zijn redelijk beperkt in hun mogelijkheden. 

\subsubsection{Genereren van correcties}
De unsatstructure is zeker een belangrijk onderdeel van het IDP systeem. In geval van een niet satisfieerbare selectie U, zal de methode op zoek gaan naar \'{e}\'{e}n precisie minimale subset V $\subseteq$ U, die niet satisfieerbaar is. Met andere woorden wijst het de oorzaak van het probleem aan, zeer nuttige informatie die de gebruiker kan bijstaan om de selectie terug satisfieerbaar te maken. Maar in plaats van de oorzaak op te sporen is het de bedoeling om oplossingen te zoeken die satisfieerbaarheid kunnen herstellen. Met oplossing wordt bedoeld de kleinste verzameling van predicaten die ongedaan gemaakt dienen te worden om het probleem terug satisfieerbaar te maken. In \citet{amilhastre2002consistency} wordt getoond hoe de oplossingsverzameling van een CSP voorgesteld kan worden door een eindige toestandsautomaat. Deze automaat, die vooraf berekend wordt kan vervolgens gebruikt worden om tijdens het selectieproces de complexiteit van de bewerkingen van verscheidene inferentie taken te reduceren en zo de reactietijd aanzienlijk te verbeteren. E\'{e}n van deze taken is het voorzien van oplossingen in geval van een niet-satisfieerbare selectie, en dit is exact hetgeen waar naar we op zoek zijn. De focus van de paper ligt op het reduceren van de complexiteit van de bewerkingen gedurende het selectieproces met behulp van de vooraf berekende automaat. En hoewel dit niet de focus is van dit onderzoek, biedt de techniek wel de inferentie taak aan die we zoeken. En met de garantie, dat de complexiteit van de bewerkingen aanzienlijk lager ligt dan normaal. De automaat is een compacte voorstelling van de oplossingsverzameling van een constraint satisfaction problem. Elk pad is een combinatie van waarden uit het domein van de variabelen die samen een correcte interpretatie vormen volgens de theorie. \citet{amilhastre2002consistency} stelt dat deze voorstelling ook gebruikt kan worden om bepaalde inferentie taken uit te voeren die deel uitmaken van het domein van interactieve configuratieproblemen. 

\paragraph{Constructie van de automaat}
De voorstelling van IDP is verschillend van de voorstelling die Amilhastre gebruikt. In IDP geeft de gebruiker invulling d.m.v. toekenning van waarheidswaarden aan de verzameling van predicaten \textit{Geselecteerd(Vak,Fase)} of \textit{GeenInteresse(Vak)}. Als de student dus waarheidswaarde true toekent aan het predicaat Geselecteerd(G0Q66C,2), betekent dit dat de student het vak \textit{Fundamenten van Computergrafiek} wil volgen in de tweede fase van diens opleiding. Door elk uniek vak voor te stellen als variabele met als domein de mogelijke fases waarin ze gegeven worden krijgen we een formaat dat nodig is voor de automaat. Voor elk vak dient 0 toegevoegd te worden aan het domein, dit voor wanneer een vak niet geselecteerd is door de gebruiker. Via dit formaat van conversie is het dus mogelijk om de automaat te construeren en er mee te communiceren.

\begin{lstlisting}[mathescape, caption=IDP Syntax conversion, frame=single]
Vak = {G0Q66C;...} $\rightarrow$ V$_{G0Q66C}$
InFase = {G0Q66C,1;G0Q66C,2;...} $\rightarrow$ D$_{V_{G0Q66C}}$ = {0,1,2}
\end{lstlisting}

De constructie bestaat uit een aantal stappen, te beginnen bij het opsommen van alle mogelijk oplossingen. Dit gebeurt in IDP door simpelweg model expansie aan te roepen en alle oplossingen op te sommen. De output van \'{e}\'{e}n geldige oplossing ziet er als volgt uit:
\begin{lstlisting}[mathescape, caption=IDP model, frame=single]
Geselecteerd = { "G0B36A",1; "G0G88A",1; "G0Q66C",1; 
"H02A8A",1; "H02C1A",1; "H02C3A",1; "H02C8A",1; "H02D2A",1;
"H04I0A",1; "H04I2A",1; "H04I4A",1; "H0T25A",1 }
\end{lstlisting}
Dit formaat wordt vervolgens omgevormd en weggeschreven in een tabel \ref{tab:oplossingen}. Vakken die niet in de verzameling staan zijn niet geselecteerd, in de tabel staat er dan een 0 in de kolom van het vak. De waarden uit de tabel worden dan vervolgens gebruikt om de een automaat mee te bouwen \ref{alg:fsaConstructie}. De automaat is niet minimaal, met behulp van het Hopcroft algoritme wordt de automaat herleid tot een minimale automaat. 

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\underline{function BouwAutomaat} (I,F,T)\;
	\Input{I de begintoestand, 
	F de eindtoestand,
	T de tabel met oplossingen}
	\Output{A de automaat}
	R $\leftarrow$ aantalRijen(T) \;
	K $\leftarrow$ aantalKolommen(T) \;
	H $\leftarrow$ I \;
	\For{i = 0, i < R, i++}
		{
		\For{j = 0, j < K, j++}
			{
			V $\leftarrow$ T[i][j] \;
			\If{!H.heeftOvergang(V)} 
				{
				\eIf {j < K-1} 
					{
					S $\leftarrow$ Toestand() \;
					}
					{
					S $\leftarrow$ F \;
					}
				T $\leftarrow$ Overgang(V,S) \;
				H.nieuweOvergang(T) \;
				}
			H $\leftarrow$ H.volg(V) \;
			}
		H $\leftarrow$ I \;
		}
	A $\leftarrow$ Automaat() \;
	A.beginToestand(I) \;
	return A \;
	\caption{Constructie Automaat\label{alg:fsaConstructie}}
\end{algorithm}

\paragraph{Gebruik van de automaat}
Eens de automaat volledig geconstrueerd is, wordt ze bewaard en kan ze vanaf dan altijd herbruikt worden. Enkel wanneer de constraints of het domein wijzigen moet er een nieuwe automaat gegenereerd worden. Dit betekent dus ook dat voor elke opleiding een andere automaat moet gebouwd en bewaard worden. 

Wellicht nog een belangrijk voordeel van de automaat is dat de ze werkt m.b.v. gewichten. Elke variabele $\mathcal{X}_{i}$ krijgt een gewicht toegekend, standaard zijn alle gewichten 1 maar door de gewichten te veranderen kunnen voorkeuren gegeven worden aan bepaalde variabelen. Het aanpassen van deze gewichten kan effici\"{e}nt gebeuren en de automaat hoeft er niet opnieuw voor opgebouwd te worden.

\section{Front-End}
Herinner dat het samenstellen van het ISP een interactief configuratieprobleem is, en om aan de eigenschappen van zo'n IC probleem te kunnen voldoen moet de reactietijd van de inferentie methoden waarop de voorheen beschreven features gebaseerd zijn snel genoeg zijn. Met snel genoeg wordt bedoeld niet meer dan enkele seconden en in sommige gevallen zelfs nog minder. Afhankelijk van hoe frequent sommige methodes gebruikt worden kunnen de eisen omtrent reactietijd verschillen, kort gezegd moeten de functies die het meest aangeroepen worden de snelste reactietijd hebben. Om dit te testen heb ik een front-end applicatie ontwikkeld die al deze features implementeert en met behulp van een grafische interface een student toelaat een ISP samen te stellen. De input van de gebruiker wordt vertaald naar FO(\textperiodcentered) en doorgespeeld naar IDP. Vervolgens voert IDP inferentie uit en de resultaten hiervan worden terug doorgespeeld naar de front-end, die het resultaat zal weergeven d.m.v. de GUI. Zo kunnen de prestaties van IDP in een gebruiksvriendelijke omgeving getest worden. 

\subsection{Grafische Gebruikersinterface}
De interface van de applicatie ziet er grotendeels gelijkaardig uit aan die van de bestaande web applicatie. Hierdoor kunnen potenti\"{e}le gebruikers die bekend zijn met de web applicatie snel vertrouwd geraken met het nieuwe systeem. 

\paragraph{Selectie venster}
De interface bestaat uit twee onderdelen, het eerste venster is dat waar de student het ISP kan samenstellen. In \ref{fig:sc1} is de weergave te zien van dit onderdeel van de applicatie. Er zijn drie secties te onderscheiden in de weergave, de grootste en wellicht de belangrijkste sectie is dat waar de structuur van de opleiding in is weergeven. De vakken staan weergeven in de blauwe kaders, die netjes gesorteerd zijn per vakgroep (groene kaders) waar ze deel van uit maken. Per vakgroep zijn de verplichte vakken gescheiden van keuzevakken (gele kaders). De vakken zelf zijn voorgesteld in een blauw kader. Bovenaan in het kader staat de naam van het vak samen met het aantal studiepunten en aan de rechtzijde staat de vak code met daaronder een (halve) cirkel die weergeeft in welk semester het vak juist gegeven wordt. Een linkse (rechtse) helft wil zeggen dat het vak in het eerste (tweede) semester valt en een cirkel wil zeggen dat het een jaarvak is. Linksonder in het blauwe vak staan de verschillende fases weergeven waarin het vak mogelijk gevolgd kan worden, als de student een vak wil volgen moet dit aangegeven worden door \'{e}\'{e}n van deze fases aan te vinken. Rechts van de fases staat een schakel knop waarmee de student kan aangeven dat hij/zij geen interesse heeft om het vak te volgen. Dit is niet verplicht, maar als de student een geldig ISP wil laten genereren door het systeem kan het hier rekening mee houden. De tweede sectie is de kolom genaamd \textit{Geschiedenis} aan de rechterzijde, waarin de acties van de gebruiker in komen te staan. Elke (de)selectie die de student maakt wordt automatisch toegevoegd aan deze lijst voor een duidelijk overzicht. De laatste sectie is de balk met functietoetsen helemaal onderaan, waarin enkele belangrijke functionaliteiten in verwerkt zitten. 
\begin{description}
\item [Genereer ISP] E\'{e}n van de nieuwe toevoegingen is de mogelijkheid om het systeem een parti\"{e}le selectie verder te vervolledigen tot een geldig ISP. Deze functie kan aangeroepen worden d.m.v. de Expand toets.
\item[Optimaal ISP] Daarnaast is het ook mogelijk om een optimaal ISP samen te stellen, volgens een bepaald criterium, dit door op 'Optimaal ISP' te klikken.
\item[Select Parameter] Optimalisatie moet dus gebeuren volgens een bepaald criterium, dit is een drop down menu waarin de student zo'n criterium kan selecteren alvorens optimalisatie uit te voeren.
\item[ECTS Distributie] De regels van het ISP bestaan voor een groot deel uit regels die bepalen hoeveel studiepunten de student moet/mag selecteren voor bepaalde vakgroepen. Om te vermijden dat de student zelf moet beginnen tellen, kan deze via 'ECTS Distributie' een duidelijk overzicht opvragen van de huidige stand der zaken. Het overzicht bevat voor elke vakgroep de eventuele onder- en bovengrens samen met de som van studiepunten van de reeds geselecteerde vakken.
\item[Maak Ongedaan] Deze toets laat de gebruiker toe om de laatste nieuwe actie ongedaan te maken. 
\end{description}

\begin{figure}
\caption{Het selectie venster van de grafische interface\label{fig:sc1}}
\centering
\includegraphics[scale=.35]{sc1.png}
\end{figure}

\paragraph{Overzicht lessenrooster} 
E\'{e}n van de doelstellingen in dit onderzoek is de integratie van het lessenrooster bij het opstellen van het ISP. Het tweede onderdeel van de interface \ref{fig:sc2} is speciaal hiervoor ontworpen. Voor de huidige selectie van de student zal telkens het bijhorende lessenrooster worden bepaald. In dit onderdeel van de applicatie kan de gebruiker een duidelijk overzicht bekijken van dit lessenrooster en eventuele overlap in lesmomenten laten berekenen. Via de kalender kan de student de dagindeling van eender welke werkdag bekijken. Opleidingen bestaan mogelijk uit meerdere fases, linksonder kan de student kiezen voor welke fase van de opleiding hij/zij het lessenrooster wil bekijken. De dagindeling staat weergegeven aan de rechterzijde van het scherm. De knop onderaan rechts berekent de totale overlap van lesmomenten per week.

\begin{figure}
\caption{Het overzicht van het lessenrooster\label{fig:sc2}}
\centering
\includegraphics[scale=.35]{sc2.png}
\end{figure}


\subsection{Communicatie tussen Front- en Back-end}
Niet alleen is de syntax tussen IDP en Python compleet verschillend, het zijn ook twee verschillende klassen van programmeertalen respectievelijk declaratief en objectgeori\"{e}nteerd. Dus communicatie tussen de twee talen is niet vanzelfsprekend. Een Python API die toelaat IDP te gebruiken is reeds ontwikkeld \citep{vennekens2015lowering}. Het doel van de API is om de kloof tussen de declaratieve omgeving van IDP en Python kleiner te maken. Door een populaire programmeertaal te kiezen hoopt de auteur dat informatici met een achtergrond in declaratieve talen en logica sneller van IDP gebruik zullen maken zelfs als ze de syntax van IDP niet meester zijn. Persoonlijk heb ik wel al ervaring met IDP en heb dus geopteerd om geen gebruik te maken van de API. De input van IDP is compleet tekstueel, de front-end moet een volledig tekst-bestand genereren in een formaat dat IDP kan begrijpen. De output van IDP is opnieuw een tekst-bestand dat de front-end zal moeten parsen om het resultaat te kunnen verwerken. Zo'n tekst-bestand heeft altijd dezelfde opmaak, het bevat een theorie, vocabularium, structuur, procedure en eventueel termen in geval van minimizatie. De front-end bevat een parser object dat voor elke oproep zo'n tekst bestand zal opbouwen. De theorie, vocabularium en de procedures zijn altijd dezelfde en hoeven slecht \'{e}\'{e}nmalig ingelezen te worden. Enkel de structuur zal bij elke nieuwe actie gedeeltelijk dynamische gegenereerd moeten worden. De interpretatie G voor $\Gamma$ is gegeven, maar de interpretatie W voor $\Omega$ moet bij elke stap opnieuw gegenereerd worden.